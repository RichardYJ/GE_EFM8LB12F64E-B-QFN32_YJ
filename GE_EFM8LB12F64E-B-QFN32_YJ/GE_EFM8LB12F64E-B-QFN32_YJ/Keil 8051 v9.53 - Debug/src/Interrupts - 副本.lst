C51 COMPILER V9.53.0.0   INTERRUPTS_______                                                 01/23/2018 16:19:52 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE INTERRUPTS_______
OBJECT MODULE PLACED IN .\src\Interrupts - ∏±±æ.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.53\BIN\C51.exe D:\WorkSpace\MyC
                    -ode\GE_EFM8LB12F64E-B-QFN32_YJ\GE_EFM8LB12F64E-B-QFN32_YJ\src\Interrupts - ∏±±æ.c OMF2 LARGE DEBUG OBJECTEXTEND ROM(LARG
                    -E) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(D:\WorkSpace\MyCo
                    -de\GE_EFM8LB12F64E-B-QFN32_YJ\GE_EFM8LB12F64E-B-QFN32_YJ\inc;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1
                    -.1//Device/shared/si8051base;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//Device/EFM8LB1/inc) PRINT(.\
                    -src\Interrupts - ∏±±æ.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\Interrupts - ∏±±æ.OBJ)

line level    source

   1          //=========================================================
   2          // src/Interrupts.c: generated by Hardware Configurator
   3          //
   4          // This file will be regenerated when saving a document.
   5          // leave the sections inside the "$[...]" comment tags alone
   6          // or they will be overwritten!!
   7          //=========================================================
   8          
   9          // USER INCLUDES
  10          #include <SI_EFM8LB1_Register_Enums.h>
  11          #include "EFM8LB1_SMBus_MasterMultibyte.h"
  12          #include "EFM8LB1_I2C_Slave.h"
  13          typedef enum {
  14                  SLAVE_NORMAL_DATA, SLAVE_DATA_ADDRESS,
  15          } SLAVE_WRITE_DATA_TYPE;
  16          
  17          extern volatile uint8_t nWR;
  18          extern uint32_t ADC_AVG;               // Accumulates the ADC samples
  19          extern bool CONV_COMPLETE;              // ADC accumulated result ready flag
  20          uint8_t iArry = 0;
  21          bool bTx_4th_byte_nack = false;
  22          
  23          //#if 1//ø™∑≈æÕª·”∞œÏSMBUS0?         µ⁄“ª¥Œ≤‚ ‘ ±SMBUS0Õ£÷π¡À£®≤ªƒ‹»∑∂®£©£¨∫Û√Ê√ø¥Œ≤‚ ‘∂º «≥…π¶µƒ£¨SMBUS0∆
             -µ¬ Œ™10.008KHZ,LED1∫√œÒ «≤ªƒ‹µ„¡¡¡À°£
  24          volatile uint8_t I2C1_slaveWriteData = 0x16;
  25          //const uint8_t cConst[10];
  26          #if 0
              uint8_t EEPROM_Buffer[3] = {0, 1, 2}; //[64] = { 0 };
              #else
  29          //pdata volatile static 
  30          uint8_t EEPROM_Buffer[] =
  31          //uint8_t EEPROM_Buffer[] =
  32                          {
  33                                          17,             //B0
  34                                          5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  35                                          0, 0, 0, 0, 0, 0, 0, 0,
  36          
  37                                          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  38                                          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  39                                          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  40                                          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 0, 0, 0,
  41                                          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  42                                          0,              //B127
  43          
  44                                          17, 0, 35,
  45                                          128,            //136
  46                                          0, 112, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 8, 70, 73, 84,
  47                                          32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 31, 0, 9, 58, 49, 48,
  48                                          48, 50, 57, 55, 49, 49, 48, 49, 32, 32, 32, 32, 32, 32, 49, 32,
  49                                          66, 104, 7, 208, 0, 99,
  50                                          2,              //CR4=11 SR4=2 AOC=1?®∞24
C51 COMPILER V9.53.0.0   INTERRUPTS_______                                                 01/23/2018 16:19:52 PAGE 2   

  51                                          0, 0, 0, 53, 50, 56, 54, 50, 48, 55, 53, 48, 32, 32, 32, 32, 32,
  52                                          32, 32, 49, 53, 49, 48, 49, 51, 32, 32, 0, 0, 0, 41,
  53          
  54                                          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  55                                          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  56          
  57                          };
  58          #endif
  59          //-----------------------------------------------------------------------------
  60          // I2C0_ISR
  61          //-----------------------------------------------------------------------------
  62          //
  63          // I2C0 ISR Content goes here. Remember to clear flag bits:
  64          // I2C0STAT::I2C0INT (I2C Interrupt)
  65          //
  66          //-----------------------------------------------------------------------------
  67          SI_INTERRUPT (I2C0_ISR, I2C0_IRQn)
  68          {
  69   1              static uint16_t eepromAddress = 0;  //for addressing larger than 256Byte
  70   1              static uint8_t slaveWriteType = SLAVE_NORMAL_DATA;
  71   1              static uint8_t WriteStat = 0;
  72   1              uint8_t t,j;
  73   1      
  74   1              uint8_t SAVE_SFRPAGE;
  75   1              bool EA_SAVE = IE_EA;                            // Preserve IE_EA
  76   1              IE_EA = 0;                                                      // Disable interrupts
  77   1              SAVE_SFRPAGE = SFRPAGE;
  78   1              SFRPAGE = 0x20;
  79   1      
  80   1              switch (I2C0STAT & I2C_STATUS_VECTOR_MASK) {
  81   2      
  82   2                      case I2C_ADDR_RD:
  83   2                      I2C0STAT &= ~(I2C0STAT_START__BMASK | I2C0STAT_RD__BMASK);
  84   2                      t = EEPROM_Buffer[eepromAddress++];
  85   2                      if(0x0==t)
  86   2                      {
  87   3                              j=t;
  88   3                      }
  89   2                      I2C0DOUT = t;//EEPROM_Buffer[eepromAddress++];
  90   2                      if(sizeof(EEPROM_Buffer) <= eepromAddress)
  91   2                      {
  92   3                              eepromAddress = 0;
  93   3                      }
  94   2                      WriteStat = 0;
  95   2                      break;
  96   2      
  97   2                      case I2C_ADDR_WR:
  98   2                      I2C0STAT &= ~(I2C0STAT_START__BMASK | I2C0STAT_WR__BMASK);
  99   2                      slaveWriteType = SLAVE_DATA_ADDRESS;
 100   2                      WriteStat = 1;
 101   2                      break;
 102   2      
 103   2                      case I2C_RD_DATA:
 104   2                      if ((I2C0STAT & I2C0STAT_NACK__BMASK) == I2C0STAT_NACK__SET) {
 105   3                              I2C0STAT &= ~I2C0STAT_NACK__BMASK;
 106   3                      } else {
 107   3                              t = EEPROM_Buffer[eepromAddress++];
 108   3                              if(0x11==t)
 109   3                              {
 110   4                                      j=t;
 111   4                              }
 112   3                              I2C0DOUT = t;
 113   3      
C51 COMPILER V9.53.0.0   INTERRUPTS_______                                                 01/23/2018 16:19:52 PAGE 3   

 114   3                              if(sizeof(EEPROM_Buffer) <= eepromAddress)
 115   3                              {
 116   4                                      eepromAddress = 0;
 117   4                              }
 118   3                      }
 119   2                      I2C0STAT &= ~I2C0STAT_RD__BMASK;
 120   2                      break;
 121   2      
 122   2                      case I2C_WR_DATA:
 123   2                      I2C0STAT &= ~I2C0STAT_WR__BMASK;
 124   2      
 125   2                      break;
 126   2      
 127   2                      case I2C_STOSTA:
 128   2                      case I2C_STOSTARD:
 129   2                      I2C0STAT &= ~I2C0STAT_STOP__BMASK;
 130   2      #if 0
                              I2C0CN0 &= ~I2C0CN0_BUSY__BMASK;                // Clear BUSY bit
                              I2C0CN0 |= I2C0FCN0_RFLSH__FLUSH | I2C0FCN0_TFLSH__FLUSH;
              #endif
 134   2                      
 135   2      //              WriteStat = 0;//added 20180122
 136   2                      return;
 137   2                      break;
 138   2      
 139   2                      case I2C_STO:
 140   2                      I2C0STAT &= ~I2C0STAT_STOP__BMASK;
 141   2      #if 0
                              I2C0CN0 &= ~I2C0CN0_BUSY__BMASK;                // Clear BUSY bit
                              I2C0CN0 |= I2C0FCN0_RFLSH__FLUSH | I2C0FCN0_TFLSH__FLUSH;
              #endif
 145   2                      
 146   2      //              WriteStat = 0;//added 20180122
 147   2                      break;
 148   2                      default:
 149   2                      break;
 150   2              }
 151   1      
 152   1              while((I2C0FCN1 & I2C0FCN1_RXE__BMASK) == I2C0FCN1_RXE__NOT_EMPTY) {
 153   2                      I2C1_slaveWriteData = I2C0DIN;
 154   2                      if(1==WriteStat&&80!=I2C1_slaveWriteData)
 155   2                      {
 156   3                              switch(slaveWriteType)
 157   3                              {
 158   4                                      case SLAVE_DATA_ADDRESS:
 159   4                                      if(I2C1_slaveWriteData>=128)
 160   4                                      {
 161   5                                              eepromAddress = I2C1_slaveWriteData+128*EEPROM_Buffer[127];
 162   5                                      }
 163   4                                      else
 164   4                                      {
 165   5                                              eepromAddress = I2C1_slaveWriteData;
 166   5                                      }
 167   4                                      break;
 168   4      
 169   4                                      case SLAVE_NORMAL_DATA:
 170   4                                      default:
 171   4                                      EEPROM_Buffer[eepromAddress++] = I2C1_slaveWriteData;
 172   4      
 173   4                                      if(sizeof(EEPROM_Buffer) <= eepromAddress)
 174   4                                      {
 175   5                                              eepromAddress = 0;
 176   5                                      }
C51 COMPILER V9.53.0.0   INTERRUPTS_______                                                 01/23/2018 16:19:52 PAGE 4   

 177   4                                      break;
 178   4                              }
 179   3      
 180   3                              slaveWriteType = SLAVE_NORMAL_DATA;
 181   3      //                      WriteStat = 0;//added 20180122
 182   3                      }
 183   2              }
 184   1      
 185   1              I2C0STAT &= ~I2C0STAT_I2C0INT__BMASK;
 186   1              SFRPAGE = SAVE_SFRPAGE;
 187   1              IE_EA = EA_SAVE;                                        // Restore interrupts
 188   1      
 189   1      }
 190          
 191          // SMBUS0_ISR
 192          //-----------------------------------------------------------------------------
 193          //
 194          // SMBUS0 ISR Content goes here. Remember to clear flag bits:
 195          // SMB0CN0::SI (SMBus Interrupt Flag)
 196          //
 197          //-----------------------------------------------------------------------------
 198          SI_INTERRUPT (SMBUS0_ISR, SMBUS0_IRQn)
 199          {
 200   1              bool FAIL = 0;                       // Used by the ISR to flag failed
 201   1                                                                                       // transfers
 202   1      
 203   1              static uint8_t sent_byte_counter;
 204   1              static uint8_t rec_byte_counter;
 205   1      
 206   1              if (SMB0CN0_ARBLOST == 0)                // Check for errors
 207   1              {
 208   2                      // Normal operation
 209   2                      switch (SMB0CN0 & 0xF0)// Status vector
 210   2                      {
 211   3                              // Master Transmitter/Receiver: START condition transmitted.
 212   3                              case SMB_MTSTA:
 213   3                              SMB0DAT = TARGET<<1;// Load address of the target slave
 214   3                              SMB0DAT &= 0xFE;        // Clear the LSB of the address for the
 215   3                                                                      // R/W bit
 216   3                              SMB0DAT |= (uint8_t) SMB_RW;// Load R/W bit
 217   3                              SMB0CN0_STA = 0;// Manually clear START bit
 218   3                              rec_byte_counter = 1;// Reset the counter
 219   3                              sent_byte_counter = 1;// Reset the counter
 220   3                              break;
 221   3      
 222   3                              // Master Transmitter: Data byte transmitted
 223   3                              case SMB_MTDB:
 224   3                              if (SMB0CN0_ACK)// Slave SMB0CN0_ACK?
 225   3                              {
 226   4                                      if (SMB_RW == WRITE)    // If this transfer is a WRITE,
 227   4                                      {
 228   5                                              if (sent_byte_counter <= nWR /*NUM_BYTES_WR*/)
 229   5                                              {
 230   6                                                      // send data byte
 231   6                                                      SMB0DAT = SMB_DATA_OUT[sent_byte_counter-1];
 232   6                                                      sent_byte_counter++;
 233   6                                              }
 234   5                                              else
 235   5                                              {
 236   6                                                      SMB0CN0_STO = 1; // Set SMB0CN0_STO to terminate transfer
 237   6                                                      SMB_BUSY = 0;// And free SMBus interface
 238   6                                              }
 239   5                                      }
C51 COMPILER V9.53.0.0   INTERRUPTS_______                                                 01/23/2018 16:19:52 PAGE 5   

 240   4                                      else {}                 // If this transfer is a READ,
 241   4                                                                                      // proceed with transfer without
 242   4                                                                                      // writing to SMB0DAT (switch
 243   4                                                                                      // to receive mode)
 244   4      
 245   4                              }
 246   3                              else                       // If slave NACK,
 247   3                              {
 248   4                                      if(bTx_4th_byte_nack)
 249   4                                      {
 250   5                                              SMB0CN0_STO = 1; // Set SMB0CN0_STO to terminate transfer
 251   5                                              SMB_BUSY = 0;// And free SMBus interface
 252   5                                              break;
 253   5                                      }
 254   4                                      SMB0CN0_STO = 1;        // Send STOP condition, followed
 255   4                                      SMB0CN0_STA = 1;// By a START
 256   4                                      NUM_ERRORS++;// Indicate error
 257   4                              }
 258   3                              break;
 259   3      
 260   3                              // Master Receiver: byte received
 261   3                              case SMB_MRDB:
 262   3                              if (rec_byte_counter < NUM_BYTES_RD)
 263   3                              {
 264   4                                      SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT; // Store received
 265   4                                                                                                                         // byte
 266   4                                      SMB0CN0_ACK = 1;                                                   // Send SMB0CN0_ACK to indicate byte received
 267   4                                      rec_byte_counter++;                                                // Increment the byte counter
 268   4                              }
 269   3                              else
 270   3                              {
 271   4                                      SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT; // Store received
 272   4                                                                                                                         // byte
 273   4                                      SMB_BUSY = 0;                                                      // Free SMBus interface
 274   4                                      SMB0CN0_ACK = 0;                                                   // Send NACK to indicate last byte
 275   4                                                                                                                         // of this transfer
 276   4      
 277   4                                      SMB0CN0_STO = 1;                                                   // Send STOP to terminate transfer
 278   4                              }
 279   3                              break;
 280   3      
 281   3                              default:
 282   3                              FAIL = 1;                  // Indicate failed transfer
 283   3                                                                                 // and handle at end of ISR
 284   3                              break;
 285   3      
 286   3                      } // end switch
 287   2              }
 288   1              else
 289   1              {
 290   2                      // SMB0CN0_ARBLOST = 1, error occurred... abort transmission
 291   2                      FAIL = 1;
 292   2              } // end SMB0CN0_ARBLOST if
 293   1      
 294   1              if (FAIL)// If the transfer failed,
 295   1              {
 296   2                      SMB0CF &= ~0x80;                 // Reset communication
 297   2                      SMB0CF |= 0x80;
 298   2                      SMB0CN0_STA = 0;
 299   2                      SMB0CN0_STO = 0;
 300   2                      SMB0CN0_ACK = 0;
 301   2      
 302   2                      SMB_BUSY = 0;// Free SMBus
C51 COMPILER V9.53.0.0   INTERRUPTS_______                                                 01/23/2018 16:19:52 PAGE 6   

 303   2      
 304   2                      FAIL = 0;
 305   2      //              LED1 = 0;
 306   2      
 307   2                      NUM_ERRORS++;// Indicate an error occurred
 308   2              }
 309   1      
 310   1              SMB0CN0_SI = 0;                     // Clear interrupt flag
 311   1      }
 312          
 313          //-----------------------------------------------------------------------------
 314          // TIMER3_ISR
 315          //-----------------------------------------------------------------------------
 316          //
 317          // TIMER3 ISR Content goes here. Remember to clear flag bits:
 318          // TMR3CN0::TF3H (Timer # High Byte Overflow Flag)
 319          // TMR3CN0::TF3L (Timer # Low Byte Overflow Flag)
 320          //
 321          //-----------------------------------------------------------------------------
 322          SI_INTERRUPT (TIMER3_ISR, TIMER3_IRQn)
 323          {
 324   1              SMB0CF &= ~0x80;                   // Disable SMBus
 325   1              SMB0CF |= 0x80;// Re-enable SMBus
 326   1              TMR3CN0 &= ~0x80;// Clear Timer3 interrupt-pending
 327   1                                         // flag
 328   1              SMB0CN0_STA = 0;
 329   1              SMB_BUSY = 0;  // Free SMBus
 330   1      }
 331          
 332          //-----------------------------------------------------------------------------
 333          // TIMER4_ISR
 334          //-----------------------------------------------------------------------------
 335          //
 336          // TIMER4 ISR Content goes here. Remember to clear flag bits:
 337          // TMR4CN0::TF4H (Timer # High Byte Overflow Flag)
 338          // TMR4CN0::TF4L (Timer # Low Byte Overflow Flag)
 339          //
 340          //-----------------------------------------------------------------------------
 341          SI_INTERRUPT (TIMER4_ISR, TIMER4_IRQn)
 342          {
 343   1              SFRPAGE = PG3_PAGE;
 344   1      
 345   1              I2C0CN0 &= ~I2C0CN0_I2C0EN__BMASK;                      // Disable I2C module
 346   1              I2C0CN0 |= I2C0CN0_I2C0EN__ENABLED;// Re-enable I2C module
 347   1      
 348   1              SFRPAGE = PG2_PAGE;
 349   1              TMR4CN0 &= ~TMR4CN0_TF4H__BMASK;// Clear Timer3 interrupt-pending flag
 350   1      
 351   1      }
 352          
 353          //-----------------------------------------------------------------------------
 354          // ADC0EOC_ISR
 355          //-----------------------------------------------------------------------------
 356          //
 357          // ADC0EOC ISR Content goes here. Remember to clear flag bits:
 358          // ADC0CN0::ADINT (Conversion Complete Interrupt Flag)
 359          //
 360          //-----------------------------------------------------------------------------
 361          SI_INTERRUPT (ADC0EOC_ISR, ADC0EOC_IRQn)
 362          {
 363   1                 ADC0CN0_ADINT = 0;               // Clear ADC0 conv. complete flag
 364   1                 ADC_AVG = ADC0/4;
 365   1                 CONV_COMPLETE = 1;               // Set result ready flag
C51 COMPILER V9.53.0.0   INTERRUPTS_______                                                 01/23/2018 16:19:52 PAGE 7   

 366   1      
 367   1      }
 368          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    757    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    264    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       2
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
