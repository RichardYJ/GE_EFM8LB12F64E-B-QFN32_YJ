C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/30/2017 19:38:12 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE GE_EFM8LB12F64E_B_QFN32_YJ_MAIN
OBJECT MODULE PLACED IN .\src\GE_EFM8LB12F64E-B-QFN32_YJ_main.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.53\BIN\C51.exe D:\WorkSpace\MyC
                    -ode\GE_EFM8LB12F64E-B-QFN32_YJ\GE_EFM8LB12F64E-B-QFN32_YJ\src\GE_EFM8LB12F64E-B-QFN32_YJ_main.c OMF2 SMALL DEBUG OBJECTE
                    -XTEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(D:\
                    -WorkSpace\MyCode\GE_EFM8LB12F64E-B-QFN32_YJ\GE_EFM8LB12F64E-B-QFN32_YJ\inc;C:/SiliconLabs/SimplicityStudio/v4/developer/
                    -sdks/8051/v4.1.1//Device/shared/si8051base;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//Device/EFM8LB1
                    -/inc) PRINT(.\src\GE_EFM8LB12F64E-B-QFN32_YJ_main.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\GE_EFM8LB12F64E-B
                    --QFN32_YJ_main.OBJ)

line level    source

   1          //-----------------------------------------------------------------------------
   2          // EFM8LB1_SMBus_MasterMultibyte.c
   3          //-----------------------------------------------------------------------------
   4          // Copyright 2014 Silicon Laboratories, Inc.
   5          // http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   6          //
   7          // Program Description:
   8          //
   9          // Example software to demonstrate the SMBus interface in Master mode.
  10          // - Interrupt-driven SMBus implementation
  11          // - Only master states defined (no slave or arbitration)
  12          // - multiple-byte SMBus data holders used for each transmit and receive
  13          // - SCL frequency defined by <SMB_FREQUENCY> constant
  14          // - SMB0CN0_ARBLOST support included
  15          // - supports multiple-byte writes and multiple-byte reads
  16          //
  17          // Resources:
  18          //   SYSCLK - 24.5 MHz HFOSC0 / 1
  19          //   SMBus  - SMBus master, SCL = 10 kHz
  20          //   Timer1 - SMBus clock source
  21          //   Timer3 - SMBus SCL low timeout detection
  22          //   P0.0   - SMBus SDA
  23          //   P0.1   - SMBus SCL
  24          //   P1.4   - LED green
  25          //   P3.4   - Display enable
  26          //
  27          //-----------------------------------------------------------------------------
  28          // How To Test: EFM8LB1 STK (SMBus Master) + EFM8LB1 STK (SMBus Slave)
  29          //-----------------------------------------------------------------------------
  30          // 1) Connect the device first EFM8LB1 STK to second EFM8LB1 STK running the
  31          //    corresponding SMBus_Slave code.
  32          // 2) Place the switch in "AEM" mode.
  33          // 3) Connect the EFM8LB1 STK board to a PC using a mini USB cable.
  34          // 4) Compile and download code to the first EFM8LB1 STK board.
  35          //    In Simplicity Studio IDE, select Run -> Debug from the menu bar,
  36          //    click the Debug button in the quick menu, or press F11.
  37          // 5) Run the code.
  38          //    In Simplicity Studio IDE, select Run -> Resume from the menu bar,
  39          //    click the Resume button in the quick menu, or press F8.
  40          // 6) a. The test will indicate proper communication with the slave by
  41          //       toggling LED1 on and off each time a value is sent and received.
  42          //    b. The best method to view the proper functionality is to run to
  43          //       the indicated line of code in the TEST CODE section of main and
  44          //       view the SMB_DATA_IN and SMB_DATA_OUT variables in the Watch
  45          //       Window.
  46          //
  47          // Target:         EFM8LB1
  48          // Tool chain:     Generic
  49          //
  50          // Release 0.1 (ST)
C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/30/2017 19:38:12 PAGE 2   

  51          //    - Initial Revision
  52          //    - 06 MAR 2015
  53          //
  54          
  55          //-----------------------------------------------------------------------------
  56          // Includes
  57          //-----------------------------------------------------------------------------
  58          #include "bsp.h"
  59          #include "uart_1.h"
  60          #include "InitDevice.h"
  61          #include <stdio.h>
  62          
  63          #include <SI_EFM8LB1_Register_Enums.h>                  // SFR declarations
  64          #include "InitDevice.h"
  65          #include "EFM8LB1_SMBus_MasterMultibyte.h"
  66          #include "EFM8LB1_I2C_Slave.h"
  67          
  68          //-----------------------------------------------------------------------------
  69          // Global Variables
  70          //-----------------------------------------------------------------------------
  71          // Global holder for SMBus data
  72          // All receive data is written here
  73          uint8_t SMB_DATA_IN[NUM_BYTES_RD];
  74          
  75          // Global holder for SMBus data.
  76          // All transmit data is read from here
  77          uint8_t SMB_DATA_OUT[NUM_BYTES_WR];
  78          
  79          uint8_t TARGET;                        // Target SMBus slave address
  80          
  81          volatile bool SMB_BUSY;                 // Software flag to indicate when the
  82                                                 // SMB_Read() or SMB_Write() functions
  83                                                 // have claimed the SMBus
  84          
  85          volatile bool SMB_RW;                   // Software flag to indicate the
  86                                                 // direction of the current transfer
  87          
  88          uint16_t NUM_ERRORS;                   // Counter for the number of errors.
  89          uint8_t nWR;
  90          
  91          
  92          
  93          
  94          
  95          
  96          uint8_t i2cReceivedData;               // Global holder for I2C data.
  97                                                 // All receive data is written
  98                                                 // here;
  99          
 100          bool dataReady = 0;                    // Set to '1' by the I2C ISR
 101                                                 // when a new data byte has been
 102                                                 // received.
 103          
 104          bool txDataReady = 1;                  // Set to '1' indicate that Tx data ready.
 105          uint8_t sendDataValue = 0;             // Transmit the data value 0-255 repeatedly.
 106          uint8_t sendDataCnt = 0;               // Transmit data counter. Count the Tx data
 107                                                 // in a I2C transaction.
 108          
 109          
 110          
 111          
 112          
 113          
C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/30/2017 19:38:12 PAGE 3   

 114          
 115          
 116          
 117          
 118          
 119          //-----------------------------------------------------------------------------
 120          // Function Prototypes
 121          //-----------------------------------------------------------------------------
 122          void SMB_Write(void);
 123          void SMB_Read(void);
 124          void T0_Waitms(uint8_t ms);
 125          
 126          bool SMB0_I2C_MasterWrite(uint16_t RegAddr, uint16_t RegValue) {
 127   1              nWR = 4;
 128   1              TARGET = SLAVE_ADDR;                     // Target the Slave for next SMBus
 129   1              SMB_DATA_OUT[0] = (RegAddr >> 8) & 0xff;
 130   1              SMB_DATA_OUT[1] = RegAddr&0xff;
 131   1              SMB_DATA_OUT[2] = (RegValue >> 8) & 0xff;
 132   1              SMB_DATA_OUT[3] = RegValue&0xff;
 133   1      //      SMB_DATA_OUT[3] = ((RegValue >> 8) & 0xff);
 134   1      //      SMB_DATA_OUT[2] = (RegValue);
 135   1              SMB_Write();                                     // Initiate SMBus write
 136   1              return 1;
 137   1      }
 138          
 139          uint16_t SMB0_I2C_MasterRead(uint16_t RegAddr) {
 140   1              uint16_t sRes;
 141   1              nWR = 2;
 142   1              TARGET = SLAVE_ADDR;                     // Target the Slave for next SMBus
 143   1              SMB_DATA_OUT[0] = (RegAddr >> 8) & 0xff;
 144   1              SMB_DATA_OUT[1] = RegAddr&0xff;
 145   1              SMB_Write();                                     // Initiate SMBus write
 146   1              TARGET = SLAVE_ADDR;
 147   1              SMB_Read();
 148   1              sRes = (SMB_DATA_IN[0] << 8) & 0xff00 | SMB_DATA_IN[1] & 0xff;
 149   1      //      sRes = SMB_DATA_IN[0] << 8 | SMB_DATA_IN[1];
 150   1              return sRes;
 151   1      }
 152          
 153          
 154          
 155          //-----------------------------------------------------------------------------
 156          // SiLabs_Startup() Routine
 157          // ----------------------------------------------------------------------------
 158          // This function is called immediately after reset, before the initialization
 159          // code is run in SILABS_STARTUP.A51 (which runs before main() ). This is a
 160          // useful place to disable the watchdog timer, which is enable by default
 161          // and may trigger before main() in some instances.
 162          //-----------------------------------------------------------------------------
 163          void SiLabs_Startup (void)
 164          {
 165   1        // Disable the watchdog here
 166   1      }
 167           
 168          //-----------------------------------------------------------------------------
 169          // Main Routine
 170          //-----------------------------------------------------------------------------
 171          //
 172          // Main routine performs all configuration tasks, then loops forever sending
 173          // and receiving SMBus data to the slave.
 174          //
 175          //-----------------------------------------------------------------------------
 176          void main (void)
C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/30/2017 19:38:12 PAGE 4   

 177          {
 178   1         volatile uint8_t dat;               // Test counter
 179   1         volatile uint8_t data_count;        // SMB_DATA_IN and SMB_DATA_OUT counter
 180   1         uint16_t i;                          // Dummy variable counters
 181   1         volatile uint16_t sI2C_rd;
 182   1      
 183   1         enter_BusFreeMode_from_RESET();
 184   1         UART1_initStdio(24500000, 115200);
 185   1      
 186   1         DISP_EN = DISP_BC_DRIVEN;           // EFM8 does not drive display
 187   1      
 188   1         // If slave is holding SDA low because of an improper SMBus reset or error
 189   1         while(!SDA)
 190   1         {
 191   2            // Provide clock pulses to allow the slave to advance out
 192   2            // of its current state. This will allow it to release SDA.
 193   2            XBR2 = XBR2_XBARE__ENABLED;      // Enable Crossbar
 194   2            SCL = 0;                         // Drive the clock low
 195   2            for(i = 0; i < 255; i++);        // Hold the clock low
 196   2            SCL = 1;                         // Release the clock
 197   2            while(!SCL);                     // Wait for open-drain
 198   2                                             // clock output to rise
 199   2            for(i = 0; i < 10; i++);         // Hold the clock high
 200   2            XBR2 = XBR2_XBARE__DISABLED;     // Disable Crossbar
 201   2         }
 202   1      
 203   1         enter_DefaultMode_from_BusFreeMode();
 204   1      
 205   1         LED1 = LED_OFF;
 206   1      
 207   1         // TEST CODE----------------------------------------------------------------
 208   1      
 209   1         dat = 0;                            // Output data counter
 210   1         NUM_ERRORS = 0;                     // Error counter
 211   1              {
 212   2                 IE_EA = 0;
 213   2                 SFRPAGE = PG3_PAGE;
 214   2                 I2C0CN0 &= ~I2C0CN0_BUSY__BMASK;        // Clear BUSY bit
 215   2                 I2C0FCN0 |= I2C0FCN0_RFLSH__FLUSH | I2C0FCN0_TFLSH__FLUSH;
 216   2                 IE_EA = 1;
 217   2              }
 218   1         while (1)
 219   1         {
 220   2      #if 0   
                    // SMBus Write Sequence
              #if 0
                    for (data_count = 0; data_count < NUM_BYTES_WR; data_count++)
                    {
                       SMB_DATA_OUT[data_count] = dat; // Define next outgoing byte
                       dat++;
                    }
              #else
                    SMB_DATA_OUT[0]=0x98;
                    SMB_DATA_OUT[1]=0x11;
                    SMB_DATA_OUT[2]=0xab;
                    SMB_DATA_OUT[3]=0xcd;
                    #endif
                    TARGET = SLAVE_ADDR;             // Target the Slave for next SMBus
                                                     // transfer
                    SMB_Write();                     // Initiate SMBus write
              
                    // SMBus Read Sequence
                    TARGET = SLAVE_ADDR;             // Target the Slave for next SMBus
C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/30/2017 19:38:12 PAGE 5   

                                                     // transfer
              //      SMB_Read();
              
                    // Check transfer data
                    for (data_count = 0; data_count < NUM_BYTES_RD; data_count++)
                    {
                       // Received data match transmit data?
                       if (SMB_DATA_IN[data_count] != SMB_DATA_OUT[data_count])
                       {
                          NUM_ERRORS++;              // Increment error counter if no
                                                     // match
                       }
                    }
              #if 0
                    // Indicate that an error has occurred (LED no longer lit)
                    if (NUM_ERRORS > 0)
                    {
                       LED1 = LED_OFF;
                    }
                    else
              #endif
              #else
 262   2      //              for (i = 0; i < 255; i++) 
 263   2                      {
 264   3      #if 1           
 265   3                              sI2C_rd = SMB0_I2C_MasterRead(0x00);
 266   3                              SMB0_I2C_MasterWrite(0x9811, 0xabcd/*i*/);
 267   3      
 268   3                              if (0x204c != sI2C_rd)
 269   3                                      printf(                                 "SMB0_I2C    ===============Read================== 0x0 ============Error!!!->0x%02X \r\n "
             -,                                        sI2C_rd);
 270   3      //                      else
 271   3      //                              printf("SMB0_I2C Read 0x0 OK  !\r\n");
 272   3      
 273   3      
 274   3      #endif
 275   3      //                      if (1 == SMB0_I2C_MasterWrite(0x9811, 0xabcd/*i*/)) {
 276   3      //                              sI2C_rd = SMB0_I2C_MasterRead(0x9811);
 277   3      //                              if (i != sI2C_rd)
 278   3      //                                      LED1 = !LED1;
 279   3      //                                      printf(                                         "SMB0_I2C ================Write========================= 0x9811 ============Error!!!\r
             -\n");
 280   3      //                              else {
 281   3      //                                      LED1 = !LED1;
 282   3      //                                      printf("SMB0_I2C Write & Read 0x9811 OK !\r\n");
 283   3      //                              }
 284   3                      }
 285   2      
 286   2      
 287   2      #endif
 288   2            {
 289   3               LED1 = !LED1;
 290   3            }
 291   2      
 292   2            // Run to here to view the SMB_DATA_IN and SMB_DATA_OUT variable arrays
 293   2      
 294   2            T0_Waitms (500);                  // Wait 50 ms until the next cycle
 295   2                                             // so that LED blinks slow enough to see
 296   2         }
 297   1      
 298   1         // END TEST CODE------------------------------------------------------------
 299   1      
 300   1      }
C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/30/2017 19:38:12 PAGE 6   

*** WARNING C280 IN LINE 179 OF D:\WorkSpace\MyCode\GE_EFM8LB12F64E-B-QFN32_YJ\GE_EFM8LB12F64E-B-QFN32_YJ\src\GE_EFM8LB1
             -2F64E-B-QFN32_YJ_main.c: 'data_count': unreferenced local variable
 301          
 302          //-----------------------------------------------------------------------------
 303          // Support Functions
 304          //-----------------------------------------------------------------------------
 305          
 306          //-----------------------------------------------------------------------------
 307          // SMB_Write
 308          //-----------------------------------------------------------------------------
 309          //
 310          // Return Value : None
 311          // Parameters   : None
 312          //
 313          // Writes a single byte to the slave with address specified by the <TARGET>
 314          // variable.
 315          // Calling sequence:
 316          // 1) Write target slave address to the <TARGET> variable
 317          // 2) Write outgoing data to the <SMB_DATA_OUT> variable array
 318          // 3) Call SMB_Write()
 319          //
 320          //-----------------------------------------------------------------------------
 321          void SMB_Write(void)
 322          {
 323   1         while(SMB_BUSY);                    // Wait for SMBus to be free.
 324   1         SMB_BUSY = 1;                       // Claim SMBus (set to busy)
 325   1         SMB_RW = 0;                         // Mark this transfer as a WRITE
 326   1         SMB0CN0_STA = 1;                    // Start transfer
 327   1      }
 328          
 329          //-----------------------------------------------------------------------------
 330          // SMB_Read
 331          //-----------------------------------------------------------------------------
 332          //
 333          // Return Value : None
 334          // Parameters   : None
 335          //
 336          // Reads a single byte from the slave with address specified by the <TARGET>
 337          // variable.
 338          // Calling sequence:
 339          // 1) Write target slave address to the <TARGET> variable
 340          // 2) Call SMB_Write()
 341          // 3) Read input data from <SMB_DATA_IN> variable array
 342          //
 343          //-----------------------------------------------------------------------------
 344          void SMB_Read(void)
 345          {
 346   1         while(SMB_BUSY);                    // Wait for bus to be free.
 347   1         SMB_BUSY = 1;                       // Claim SMBus (set to busy)
 348   1         SMB_RW = 1;                         // Mark this transfer as a READ
 349   1      
 350   1         SMB0CN0_STA = 1;                    // Start transfer
 351   1      
 352   1         while(SMB_BUSY);                    // Wait for transfer to complete
 353   1      }
 354          
 355          //-----------------------------------------------------------------------------
 356          // T0_Waitms
 357          //-----------------------------------------------------------------------------
 358          //
 359          // Return Value : None
 360          // Parameters   :
 361          //   1) uint8_t ms - number of milliseconds to wait
C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/30/2017 19:38:12 PAGE 7   

 362          //                        range is full range of character: 0 to 255
 363          //
 364          // Configure Timer0 to wait for <ms> milliseconds using SYSCLK as its time
 365          // base.
 366          //
 367          //-----------------------------------------------------------------------------
 368          void T0_Waitms(uint8_t ms)
 369          {
 370   1         TCON &= ~0x30;                      // Stop Timer0; Clear TCON_TF0
 371   1         TMOD &= ~0x0f;                      // 16-bit free run mode
 372   1         TMOD |=  0x01;
 373   1      
 374   1         CKCON0 |= 0x04;                     // Timer0 counts SYSCLKs
 375   1      
 376   1         while (ms)
 377   1         {
 378   2            TCON_TR0 = 0;                    // Stop Timer0
 379   2            TH0 = ((-SYSCLK/1000) >> 8);     // Overflow in 1ms
 380   2            TL0 = ((-SYSCLK/1000) & 0xFF);
 381   2            TCON_TF0 = 0;                    // Clear overflow indicator
 382   2            TCON_TR0 = 1;                    // Start Timer0
 383   2            while (!TCON_TF0);               // Wait for overflow
 384   2            ms--;                            // Update ms counter
 385   2         }
 386   1      
 387   1         TCON_TR0 = 0;                       // Stop Timer0
 388   1      }
 389          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    272    ----
   CONSTANT SIZE    =     87    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     13       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
