C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/30/2017 18:25:18 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE GE_EFM8LB12F64E_B_QFN32_YJ_MAIN
OBJECT MODULE PLACED IN .\src\GE_EFM8LB12F64E-B-QFN32_YJ_main.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.53\BIN\C51.exe D:\WorkSpace\MyC
                    -ode\GE_EFM8LB12F64E-B-QFN32_YJ\GE_EFM8LB12F64E-B-QFN32_YJ\src\GE_EFM8LB12F64E-B-QFN32_YJ_main.c OMF2 SMALL DEBUG OBJECTE
                    -XTEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(D:\
                    -WorkSpace\MyCode\GE_EFM8LB12F64E-B-QFN32_YJ\GE_EFM8LB12F64E-B-QFN32_YJ\inc;C:/SiliconLabs/SimplicityStudio/v4/developer/
                    -sdks/8051/v4.1.1//Device/shared/si8051base;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//Device/EFM8LB1
                    -/inc) PRINT(.\src\GE_EFM8LB12F64E-B-QFN32_YJ_main.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\GE_EFM8LB12F64E-B
                    --QFN32_YJ_main.OBJ)

line level    source

   1          //-----------------------------------------------------------------------------
   2          // EFM8LB1_SMBus_MasterMultibyte.c
   3          //-----------------------------------------------------------------------------
   4          // Copyright 2014 Silicon Laboratories, Inc.
   5          // http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt
   6          //
   7          // Program Description:
   8          //
   9          // Example software to demonstrate the SMBus interface in Master mode.
  10          // - Interrupt-driven SMBus implementation
  11          // - Only master states defined (no slave or arbitration)
  12          // - multiple-byte SMBus data holders used for each transmit and receive
  13          // - SCL frequency defined by <SMB_FREQUENCY> constant
  14          // - SMB0CN0_ARBLOST support included
  15          // - supports multiple-byte writes and multiple-byte reads
  16          //
  17          // Resources:
  18          //   SYSCLK - 24.5 MHz HFOSC0 / 1
  19          //   SMBus  - SMBus master, SCL = 10 kHz
  20          //   Timer1 - SMBus clock source
  21          //   Timer3 - SMBus SCL low timeout detection
  22          //   P0.0   - SMBus SDA
  23          //   P0.1   - SMBus SCL
  24          //   P1.4   - LED green
  25          //   P3.4   - Display enable
  26          //
  27          //-----------------------------------------------------------------------------
  28          // How To Test: EFM8LB1 STK (SMBus Master) + EFM8LB1 STK (SMBus Slave)
  29          //-----------------------------------------------------------------------------
  30          // 1) Connect the device first EFM8LB1 STK to second EFM8LB1 STK running the
  31          //    corresponding SMBus_Slave code.
  32          // 2) Place the switch in "AEM" mode.
  33          // 3) Connect the EFM8LB1 STK board to a PC using a mini USB cable.
  34          // 4) Compile and download code to the first EFM8LB1 STK board.
  35          //    In Simplicity Studio IDE, select Run -> Debug from the menu bar,
  36          //    click the Debug button in the quick menu, or press F11.
  37          // 5) Run the code.
  38          //    In Simplicity Studio IDE, select Run -> Resume from the menu bar,
  39          //    click the Resume button in the quick menu, or press F8.
  40          // 6) a. The test will indicate proper communication with the slave by
  41          //       toggling LED1 on and off each time a value is sent and received.
  42          //    b. The best method to view the proper functionality is to run to
  43          //       the indicated line of code in the TEST CODE section of main and
  44          //       view the SMB_DATA_IN and SMB_DATA_OUT variables in the Watch
  45          //       Window.
  46          //
  47          // Target:         EFM8LB1
  48          // Tool chain:     Generic
  49          //
  50          // Release 0.1 (ST)
C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/30/2017 18:25:18 PAGE 2   

  51          //    - Initial Revision
  52          //    - 06 MAR 2015
  53          //
  54          
  55          //-----------------------------------------------------------------------------
  56          // Includes
  57          //-----------------------------------------------------------------------------
  58          #include "bsp.h"
  59          #include "uart_1.h"
  60          #include "InitDevice.h"
  61          #include <stdio.h>
  62          
  63          #include <SI_EFM8LB1_Register_Enums.h>                  // SFR declarations
  64          #include "InitDevice.h"
  65          #include "EFM8LB1_SMBus_MasterMultibyte.h"
  66          
  67          //-----------------------------------------------------------------------------
  68          // Global Variables
  69          //-----------------------------------------------------------------------------
  70          // Global holder for SMBus data
  71          // All receive data is written here
  72          uint8_t SMB_DATA_IN[NUM_BYTES_RD];
  73          
  74          // Global holder for SMBus data.
  75          // All transmit data is read from here
  76          uint8_t SMB_DATA_OUT[NUM_BYTES_WR];
  77          
  78          uint8_t TARGET;                        // Target SMBus slave address
  79          
  80          volatile bool SMB_BUSY;                 // Software flag to indicate when the
  81                                                 // SMB_Read() or SMB_Write() functions
  82                                                 // have claimed the SMBus
  83          
  84          volatile bool SMB_RW;                   // Software flag to indicate the
  85                                                 // direction of the current transfer
  86          
  87          uint16_t NUM_ERRORS;                   // Counter for the number of errors.
  88          uint8_t nWR;
  89          
  90          //-----------------------------------------------------------------------------
  91          // Function Prototypes
  92          //-----------------------------------------------------------------------------
  93          void SMB_Write(void);
  94          void SMB_Read(void);
  95          void T0_Waitms(uint8_t ms);
  96          
  97          bool SMB0_I2C_MasterWrite(uint16_t RegAddr, uint16_t RegValue) {
  98   1              nWR = 4;
  99   1              TARGET = SLAVE_ADDR;                     // Target the Slave for next SMBus
 100   1              SMB_DATA_OUT[0] = (RegAddr >> 8) & 0xff;
 101   1              SMB_DATA_OUT[1] = RegAddr&0xff;
 102   1              SMB_DATA_OUT[2] = (RegValue >> 8) & 0xff;
 103   1              SMB_DATA_OUT[3] = RegValue&0xff;
 104   1      //      SMB_DATA_OUT[3] = ((RegValue >> 8) & 0xff);
 105   1      //      SMB_DATA_OUT[2] = (RegValue);
 106   1              SMB_Write();                                     // Initiate SMBus write
 107   1              return 1;
 108   1      }
 109          
 110          uint16_t SMB0_I2C_MasterRead(uint16_t RegAddr) {
 111   1              uint16_t sRes;
 112   1              nWR = 2;
 113   1              TARGET = SLAVE_ADDR;                     // Target the Slave for next SMBus
C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/30/2017 18:25:18 PAGE 3   

 114   1              SMB_DATA_OUT[0] = (RegAddr >> 8) & 0xff;
 115   1              SMB_DATA_OUT[1] = RegAddr&0xff;
 116   1              SMB_Write();                                     // Initiate SMBus write
 117   1              TARGET = SLAVE_ADDR;
 118   1              SMB_Read();
 119   1              sRes = (SMB_DATA_IN[0] << 8) & 0xff00 | SMB_DATA_IN[1] & 0xff;
 120   1      //      sRes = SMB_DATA_IN[0] << 8 | SMB_DATA_IN[1];
 121   1              return sRes;
 122   1      }
 123          
 124          
 125          
 126          //-----------------------------------------------------------------------------
 127          // SiLabs_Startup() Routine
 128          // ----------------------------------------------------------------------------
 129          // This function is called immediately after reset, before the initialization
 130          // code is run in SILABS_STARTUP.A51 (which runs before main() ). This is a
 131          // useful place to disable the watchdog timer, which is enable by default
 132          // and may trigger before main() in some instances.
 133          //-----------------------------------------------------------------------------
 134          void SiLabs_Startup (void)
 135          {
 136   1        // Disable the watchdog here
 137   1      }
 138           
 139          //-----------------------------------------------------------------------------
 140          // Main Routine
 141          //-----------------------------------------------------------------------------
 142          //
 143          // Main routine performs all configuration tasks, then loops forever sending
 144          // and receiving SMBus data to the slave.
 145          //
 146          //-----------------------------------------------------------------------------
 147          void main (void)
 148          {
 149   1         volatile uint8_t dat;               // Test counter
 150   1         volatile uint8_t data_count;        // SMB_DATA_IN and SMB_DATA_OUT counter
 151   1         uint16_t i;                          // Dummy variable counters
 152   1         volatile uint16_t sI2C_rd;
 153   1      
 154   1         enter_BusFreeMode_from_RESET();
 155   1         UART1_initStdio(24500000, 115200);
 156   1      
 157   1         DISP_EN = DISP_BC_DRIVEN;           // EFM8 does not drive display
 158   1      
 159   1         // If slave is holding SDA low because of an improper SMBus reset or error
 160   1         while(!SDA)
 161   1         {
 162   2            // Provide clock pulses to allow the slave to advance out
 163   2            // of its current state. This will allow it to release SDA.
 164   2            XBR2 = XBR2_XBARE__ENABLED;      // Enable Crossbar
 165   2            SCL = 0;                         // Drive the clock low
 166   2            for(i = 0; i < 255; i++);        // Hold the clock low
 167   2            SCL = 1;                         // Release the clock
 168   2            while(!SCL);                     // Wait for open-drain
 169   2                                             // clock output to rise
 170   2            for(i = 0; i < 10; i++);         // Hold the clock high
 171   2            XBR2 = XBR2_XBARE__DISABLED;     // Disable Crossbar
 172   2         }
 173   1      
 174   1         enter_DefaultMode_from_BusFreeMode();
 175   1      
 176   1         LED1 = LED_OFF;
C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/30/2017 18:25:18 PAGE 4   

 177   1      
 178   1         // TEST CODE----------------------------------------------------------------
 179   1      
 180   1         dat = 0;                            // Output data counter
 181   1         NUM_ERRORS = 0;                     // Error counter
 182   1      
 183   1         while (1)
 184   1         {
 185   2      #if 0   
                    // SMBus Write Sequence
              #if 0
                    for (data_count = 0; data_count < NUM_BYTES_WR; data_count++)
                    {
                       SMB_DATA_OUT[data_count] = dat; // Define next outgoing byte
                       dat++;
                    }
              #else
                    SMB_DATA_OUT[0]=0x98;
                    SMB_DATA_OUT[1]=0x11;
                    SMB_DATA_OUT[2]=0xab;
                    SMB_DATA_OUT[3]=0xcd;
                    #endif
                    TARGET = SLAVE_ADDR;             // Target the Slave for next SMBus
                                                     // transfer
                    SMB_Write();                     // Initiate SMBus write
              
                    // SMBus Read Sequence
                    TARGET = SLAVE_ADDR;             // Target the Slave for next SMBus
                                                     // transfer
              //      SMB_Read();
              
                    // Check transfer data
                    for (data_count = 0; data_count < NUM_BYTES_RD; data_count++)
                    {
                       // Received data match transmit data?
                       if (SMB_DATA_IN[data_count] != SMB_DATA_OUT[data_count])
                       {
                          NUM_ERRORS++;              // Increment error counter if no
                                                     // match
                       }
                    }
              #if 0
                    // Indicate that an error has occurred (LED no longer lit)
                    if (NUM_ERRORS > 0)
                    {
                       LED1 = LED_OFF;
                    }
                    else
              #endif
              #else
 227   2      //              for (i = 0; i < 255; i++) 
 228   2                      {
 229   3      #if 1           
 230   3                              sI2C_rd = SMB0_I2C_MasterRead(0x00);
 231   3                              SMB0_I2C_MasterWrite(0x9811, 0xabcd/*i*/);
 232   3      
 233   3                              if (0x204c != sI2C_rd)
 234   3                                      printf(                                 "SMB0_I2C    ===============Read================== 0x0 ============Error!!!->0x%02X \r\n "
             -,                                        sI2C_rd);
 235   3      //                      else
 236   3      //                              printf("SMB0_I2C Read 0x0 OK  !\r\n");
 237   3      
 238   3      
C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/30/2017 18:25:18 PAGE 5   

 239   3      #endif
 240   3      //                      if (1 == SMB0_I2C_MasterWrite(0x9811, 0xabcd/*i*/)) {
 241   3      //                              sI2C_rd = SMB0_I2C_MasterRead(0x9811);
 242   3      //                              if (i != sI2C_rd)
 243   3      //                                      LED1 = !LED1;
 244   3      //                                      printf(                                         "SMB0_I2C ================Write========================= 0x9811 ============Error!!!\r
             -\n");
 245   3      //                              else {
 246   3      //                                      LED1 = !LED1;
 247   3      //                                      printf("SMB0_I2C Write & Read 0x9811 OK !\r\n");
 248   3      //                              }
 249   3                      }
 250   2      
 251   2      
 252   2      #endif
 253   2            {
 254   3               LED1 = !LED1;
 255   3            }
 256   2      
 257   2            // Run to here to view the SMB_DATA_IN and SMB_DATA_OUT variable arrays
 258   2      
 259   2            T0_Waitms (500);                  // Wait 50 ms until the next cycle
 260   2                                             // so that LED blinks slow enough to see
 261   2         }
 262   1      
 263   1         // END TEST CODE------------------------------------------------------------
 264   1      
 265   1      }
*** WARNING C280 IN LINE 150 OF D:\WorkSpace\MyCode\GE_EFM8LB12F64E-B-QFN32_YJ\GE_EFM8LB12F64E-B-QFN32_YJ\src\GE_EFM8LB1
             -2F64E-B-QFN32_YJ_main.c: 'data_count': unreferenced local variable
 266          
 267          //-----------------------------------------------------------------------------
 268          // Support Functions
 269          //-----------------------------------------------------------------------------
 270          
 271          //-----------------------------------------------------------------------------
 272          // SMB_Write
 273          //-----------------------------------------------------------------------------
 274          //
 275          // Return Value : None
 276          // Parameters   : None
 277          //
 278          // Writes a single byte to the slave with address specified by the <TARGET>
 279          // variable.
 280          // Calling sequence:
 281          // 1) Write target slave address to the <TARGET> variable
 282          // 2) Write outgoing data to the <SMB_DATA_OUT> variable array
 283          // 3) Call SMB_Write()
 284          //
 285          //-----------------------------------------------------------------------------
 286          void SMB_Write(void)
 287          {
 288   1         while(SMB_BUSY);                    // Wait for SMBus to be free.
 289   1         SMB_BUSY = 1;                       // Claim SMBus (set to busy)
 290   1         SMB_RW = 0;                         // Mark this transfer as a WRITE
 291   1         SMB0CN0_STA = 1;                    // Start transfer
 292   1      }
 293          
 294          //-----------------------------------------------------------------------------
 295          // SMB_Read
 296          //-----------------------------------------------------------------------------
 297          //
 298          // Return Value : None
C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/30/2017 18:25:18 PAGE 6   

 299          // Parameters   : None
 300          //
 301          // Reads a single byte from the slave with address specified by the <TARGET>
 302          // variable.
 303          // Calling sequence:
 304          // 1) Write target slave address to the <TARGET> variable
 305          // 2) Call SMB_Write()
 306          // 3) Read input data from <SMB_DATA_IN> variable array
 307          //
 308          //-----------------------------------------------------------------------------
 309          void SMB_Read(void)
 310          {
 311   1         while(SMB_BUSY);                    // Wait for bus to be free.
 312   1         SMB_BUSY = 1;                       // Claim SMBus (set to busy)
 313   1         SMB_RW = 1;                         // Mark this transfer as a READ
 314   1      
 315   1         SMB0CN0_STA = 1;                    // Start transfer
 316   1      
 317   1         while(SMB_BUSY);                    // Wait for transfer to complete
 318   1      }
 319          
 320          //-----------------------------------------------------------------------------
 321          // T0_Waitms
 322          //-----------------------------------------------------------------------------
 323          //
 324          // Return Value : None
 325          // Parameters   :
 326          //   1) uint8_t ms - number of milliseconds to wait
 327          //                        range is full range of character: 0 to 255
 328          //
 329          // Configure Timer0 to wait for <ms> milliseconds using SYSCLK as its time
 330          // base.
 331          //
 332          //-----------------------------------------------------------------------------
 333          void T0_Waitms(uint8_t ms)
 334          {
 335   1         TCON &= ~0x30;                      // Stop Timer0; Clear TCON_TF0
 336   1         TMOD &= ~0x0f;                      // 16-bit free run mode
 337   1         TMOD |=  0x01;
 338   1      
 339   1         CKCON0 |= 0x04;                     // Timer0 counts SYSCLKs
 340   1      
 341   1         while (ms)
 342   1         {
 343   2            TCON_TR0 = 0;                    // Stop Timer0
 344   2            TH0 = ((-SYSCLK/1000) >> 8);     // Overflow in 1ms
 345   2            TL0 = ((-SYSCLK/1000) & 0xFF);
 346   2            TCON_TF0 = 0;                    // Clear overflow indicator
 347   2            TCON_TR0 = 1;                    // Start Timer0
 348   2            while (!TCON_TF0);               // Wait for overflow
 349   2            ms--;                            // Update ms counter
 350   2         }
 351   1      
 352   1         TCON_TR0 = 0;                       // Stop Timer0
 353   1      }
 354          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    259    ----
   CONSTANT SIZE    =     87    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/30/2017 18:25:18 PAGE 7   

   DATA SIZE        =     10       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
