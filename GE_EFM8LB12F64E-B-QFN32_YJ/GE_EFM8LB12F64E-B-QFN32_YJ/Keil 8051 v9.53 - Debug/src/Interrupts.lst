C51 COMPILER V9.53.0.0   INTERRUPTS                                                        12/30/2017 21:06:24 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE INTERRUPTS
OBJECT MODULE PLACED IN .\src\Interrupts.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.53\BIN\C51.exe D:\WorkSpace\MyC
                    -ode\GE_EFM8LB12F64E-B-QFN32_YJ\GE_EFM8LB12F64E-B-QFN32_YJ\src\Interrupts.c OMF2 LARGE DEBUG OBJECTEXTEND ROM(LARGE) WARN
                    -INGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(D:\WorkSpace\MyCode\GE_E
                    -FM8LB12F64E-B-QFN32_YJ\GE_EFM8LB12F64E-B-QFN32_YJ\inc;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//Dev
                    -ice/shared/si8051base;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//Device/EFM8LB1/inc) PRINT(.\src\Int
                    -errupts.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\Interrupts.OBJ)

line level    source

   1          //=========================================================
   2          // src/Interrupts.c: generated by Hardware Configurator
   3          //
   4          // This file will be regenerated when saving a document.
   5          // leave the sections inside the "$[...]" comment tags alone
   6          // or they will be overwritten!!
   7          //=========================================================
   8          
   9          // USER INCLUDES
  10          #include <SI_EFM8LB1_Register_Enums.h>
  11          #include "EFM8LB1_SMBus_MasterMultibyte.h"
  12          #include "EFM8LB1_I2C_Slave.h"
  13          typedef enum {
  14                  SLAVE_NORMAL_DATA, SLAVE_DATA_ADDRESS,
  15          } SLAVE_WRITE_DATA_TYPE;
  16          
  17          #if 1//ø™∑≈æÕª·”∞œÏSMBUS0?         µ⁄“ª¥Œ≤‚ ‘ ±SMBUS0Õ£÷π¡À£®≤ªƒ‹»∑∂®£©£¨∫Û√Ê√ø¥Œ≤‚ ‘∂º «≥…π¶µƒ£¨SMBUS0∆µ¬
             - Œ™10.008KHZ,LED1∫√œÒ «≤ªƒ‹µ„¡¡¡À°£
  18          volatile uint8_t I2C1_slaveWriteData = 0x16;
  19          //const uint8_t cConst[10];
  20          #if 0
              uint8_t EEPROM_Buffer[3] = { 0, 1, 2 }; //[64] = { 0 };
              #else
  23          uint8_t EEPROM_Buffer[] =
  24          //uint8_t EEPROM_Buffer[] =
  25          {
  26                  17,             //B0
  27                  5,
  28                  6,
  29                  0,
  30                  0,
  31                  0,
  32                  0,
  33                  0,
  34                  0,
  35                  0,
  36                  0,
  37                  0,
  38                  0,
  39                  0,
  40                  0,
  41                  0,
  42                  0,
  43                  0,
  44                  0,
  45                  0,
  46                  0,
  47                  0,
  48                  0,
  49                  0,
  50                  0,
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        12/30/2017 21:06:24 PAGE 2   

  51                  0,
  52                  0,
  53                  0,
  54                  0,
  55                  0,
  56          
  57                  0,
  58                  0,
  59                  0,
  60                  0,
  61                  0,
  62                  0,
  63                  0,
  64                  0,
  65                  0,
  66                  0,
  67                  0,
  68                  0,
  69                  0,
  70                  0,
  71                  0,
  72                  0,
  73                  0,
  74                  0,
  75                  0,
  76                  0,
  77                  0,
  78                  0,
  79                  0,
  80                  0,
  81                  0,
  82                  0,
  83                  0,
  84                  0,
  85                  0,
  86                  0,
  87                  0,
  88                  0,
  89                  0,
  90                  0,
  91                  0,
  92                  0,
  93                  0,
  94                  0,
  95                  0,
  96                  0,
  97                  0,
  98                  0,
  99                  0,
 100                  0,
 101                  0,
 102                  0,
 103                  0,
 104                  0,
 105                  0,
 106                  0,
 107                  0,
 108                  0,
 109                  0,
 110                  0,
 111                  0,
 112                  0,
 113                  0,
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        12/30/2017 21:06:24 PAGE 3   

 114                  0,
 115                  0,
 116                  0,
 117                  0,
 118                  0,
 119                  0,
 120                  0,
 121                  0,
 122                  0,
 123                  0,
 124                  0,
 125                  0,
 126                  0,
 127                  0,
 128                  0,
 129                  0,
 130                  0,
 131                  0,
 132                  0,
 133                  0,
 134                  0,
 135                  0,
 136                  0,
 137                  56,
 138                  0,
 139                  0,
 140                  0,
 141                  0,
 142                  0,
 143                  0,
 144                  0,
 145                  0,
 146                  0,
 147                  0,
 148                  0,
 149                  0,
 150                  0,
 151                  0,
 152                  0,
 153                  0,
 154                  0,//B127
 155          
 156                  17,
 157                  0,
 158                  35,
 159                  128,//136
 160                  0,
 161                  112,
 162                  0,
 163                  0,
 164                  0,
 165                  0,
 166                  0,
 167                  0,
 168                  0,
 169                  0,
 170                  0,
 171                  0,
 172                  0,
 173                  0,
 174                  1,
 175                  8,
 176                  70,
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        12/30/2017 21:06:24 PAGE 4   

 177                  73,
 178                  84,
 179                  32,
 180                  0,
 181                  0,
 182                  0,
 183                  0,
 184                  0,
 185                  0,
 186                  0,
 187                  0,
 188                  0,
 189                  0,
 190                  0,
 191                  0,
 192                  31,
 193                  0,
 194                  9,
 195                  58,
 196                  49,
 197                  48,
 198                  48,
 199                  50,
 200                  57,
 201                  55,
 202                  49,
 203                  49,
 204                  48,
 205                  49,
 206                  32,
 207                  32,
 208                  32,
 209                  32,
 210                  32,
 211                  32,
 212                  49,
 213                  32,
 214                  66,
 215                  104,
 216                  7,
 217                  208,
 218                  0,
 219                  99,
 220                  2,//CR4=11 SR4=2 AOC=1?®∞24
 221                  0,
 222                  0,
 223                  0,
 224                  53,
 225                  50,
 226                  56,
 227                  54,
 228                  50,
 229                  48,
 230                  55,
 231                  53,
 232                  48,
 233                  32,
 234                  32,
 235                  32,
 236                  32,
 237                  32,
 238                  32,
 239                  32,
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        12/30/2017 21:06:24 PAGE 5   

 240                  49,
 241                  53,
 242                  49,
 243                  48,
 244                  49,
 245                  51,
 246                  32,
 247                  32,
 248                  0,
 249                  0,
 250                  0,
 251                  41,
 252          
 253                  0,
 254                  0,
 255                  0,
 256                  0,
 257                  0,
 258                  0,
 259                  0,
 260                  0,
 261                  0,
 262                  0,
 263                  0,
 264                  0,
 265                  0,
 266                  0,
 267                  0,
 268                  0,
 269                  0,
 270                  0,
 271                  0,
 272                  0,
 273                  0,
 274                  0,
 275                  0,
 276                  0,
 277                  0,
 278                  0,
 279                  0,
 280                  0,
 281                  0,
 282                  0,
 283                  0,
 284                  0,
 285          
 286          };
 287          #endif
 288          
 289          //-----------------------------------------------------------------------------
 290          // I2C0_ISR
 291          //-----------------------------------------------------------------------------
 292          //
 293          // I2C0 ISR Content goes here. Remember to clear flag bits:
 294          // I2C0STAT::I2C0INT (I2C Interrupt)
 295          //
 296          //-----------------------------------------------------------------------------
 297          SI_INTERRUPT (I2C0_ISR, I2C0_IRQn)
 298          {
 299   1              static uint16_t eepromAddress = 0;  //for addressing larger than 256Byte
 300   1              static uint8_t slaveWriteType = SLAVE_NORMAL_DATA;
 301   1              static uint8_t WriteStat;
 302   1      
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        12/30/2017 21:06:24 PAGE 6   

 303   1              switch (I2C0STAT & I2C_STATUS_VECTOR_MASK) {
 304   2      
 305   2                      case I2C_ADDR_RD:
 306   2                      I2C0STAT &= ~(I2C0STAT_START__BMASK | I2C0STAT_RD__BMASK);
 307   2                      I2C0DOUT = EEPROM_Buffer[eepromAddress++];
 308   2                      if(sizeof(EEPROM_Buffer) <= eepromAddress)
 309   2                      {
 310   3                              eepromAddress = 0;
 311   3                      }
 312   2                      break;
 313   2      
 314   2                      case I2C_ADDR_WR:
 315   2                      I2C0STAT &= ~(I2C0STAT_START__BMASK | I2C0STAT_WR__BMASK);
 316   2                      slaveWriteType = SLAVE_DATA_ADDRESS;
 317   2                      WriteStat = 1;
 318   2                      break;
 319   2      
 320   2                      case I2C_RD_DATA:
 321   2                      if ((I2C0STAT & I2C0STAT_NACK__BMASK) == I2C0STAT_NACK__SET) {
 322   3                              I2C0STAT &= ~I2C0STAT_NACK__BMASK;
 323   3                      } else {
 324   3                              I2C0DOUT = EEPROM_Buffer[eepromAddress++];
 325   3                              if(sizeof(EEPROM_Buffer) <= eepromAddress)
 326   3                              {
 327   4                                      eepromAddress = 0;
 328   4                              }
 329   3                      }
 330   2                      I2C0STAT &= ~I2C0STAT_RD__BMASK;
 331   2                      break;
 332   2      
 333   2                      case I2C_WR_DATA:
 334   2                      I2C0STAT &= ~I2C0STAT_WR__BMASK;
 335   2      
 336   2                      break;
 337   2      
 338   2                      case I2C_STOSTA:
 339   2                      case I2C_STOSTARD:
 340   2                      I2C0STAT &= ~I2C0STAT_STOP__BMASK;
 341   2                      return;
 342   2                      break;
 343   2      
 344   2                      case I2C_STO:
 345   2                      I2C0STAT &= ~I2C0STAT_STOP__BMASK;
 346   2                      break;
 347   2                      default:
 348   2                      break;
 349   2              }
 350   1      
 351   1              while((I2C0FCN1 & I2C0FCN1_RXE__BMASK) == I2C0FCN1_RXE__NOT_EMPTY) {
 352   2                      I2C1_slaveWriteData = I2C0DIN;
 353   2                      if(1==WriteStat&&80!=I2C1_slaveWriteData)
 354   2                      {
 355   3                              switch(slaveWriteType)
 356   3                              {
 357   4                                      case SLAVE_DATA_ADDRESS:
 358   4                                      if(I2C1_slaveWriteData>=128)
 359   4                                      {
 360   5                                              eepromAddress = I2C1_slaveWriteData+128*EEPROM_Buffer[127];
 361   5                                      }
 362   4                                      else
 363   4                                      {
 364   5                                              eepromAddress = I2C1_slaveWriteData;
 365   5                                      }
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        12/30/2017 21:06:24 PAGE 7   

 366   4                                      break;
 367   4      
 368   4                                      case SLAVE_NORMAL_DATA:
 369   4                                      default:
 370   4                                      EEPROM_Buffer[eepromAddress++] = I2C1_slaveWriteData;
 371   4      
 372   4                                      if(sizeof(EEPROM_Buffer) <= eepromAddress)
 373   4                                      {
 374   5                                              eepromAddress = 0;
 375   5                                      }
 376   4                                      break;
 377   4                              }
 378   3      
 379   3                              slaveWriteType = SLAVE_NORMAL_DATA;
 380   3                      }
 381   2              }
 382   1      
 383   1              I2C0STAT &= ~I2C0STAT_I2C0INT__BMASK;
 384   1      
 385   1      }
 386          #else
              
              //-----------------------------------------------------------------------------
              // I2C0_ISR
              //-----------------------------------------------------------------------------
              //
              // I2C0 ISR Content goes here. Remember to clear flag bits:
              // I2C0STAT::I2C0INT (I2C Interrupt)
              //
              //-----------------------------------------------------------------------------
              SI_INTERRUPT (I2C0_ISR, I2C0_IRQn)
              {
                      //  Number of bytes in the transmit FIFO and shift register
                      uint8_t txCnt = 0;
              
                      if((I2C0FCN1 & I2C0FCN1_TFRQ__BMASK) && (txDataReady == 1))
                      {
                              // Firmware fill the TX FIFO until the TX FIFO full, and it should
                              // locate at the beginning of the ISR, because the switch below may
                              // consume so much system cycle.
                              while((I2C0FCN1 & I2C0FCN1_TXNF__BMASK) == I2C0FCN1_TXNF__NOT_FULL)
                              {
                                      if ((I2C0STAT & I2C0STAT_NACK__BMASK) == I2C0STAT_NACK__SET)
                                      {
                                              // Master did not NACK
                                              // Stopping transfer of data
                                              // Flush FIFO if there is data in it
                                              I2C0STAT &= ~I2C0STAT_NACK__BMASK;
                                      }
                                      else
                                      {
                                              I2C0DOUT = sendDataValue++;
                                              sendDataCnt++;
                                      }
                              }
                              // The TFRQ will not set I2C0INT bit, so don't need to clear
                              // the I2C0INT when TFRQ happen.
                              // Other interrupts may be generated while dealing with the TFRQ,
                              // so just return to avoid clearing other interrupts.
                              return;
                      }
              
                      if(I2C0FCN1 & I2C0FCN1_RFRQ__SET)
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        12/30/2017 21:06:24 PAGE 8   

                      {
                              while((I2C0FCN1 & I2C0FCN1_RXE__BMASK) == I2C0FCN1_RXE__NOT_EMPTY)
                              { // Read data out
                                      i2cReceivedData   = I2C0DIN;
                                      // This example only supports host write 1 byte to slave
                                      // If want slave to accept more than 1 byte, use a buffer to save the data from FIFO
                                      dataReady = 1;
                              }
                              // Other interrupts may be generated while dealing with the RFRQ,
                              // so just return to avoid clearing other interrupts.
                              return;
                      }
              
                      switch (I2C0STAT & I2C_STATUS_VECTOR_MASK)
                      {
              
                              case I2C_ADDR_RD:  // START+ADDR+R
                                      I2C0STAT &= ~(I2C0STAT_START__BMASK | I2C0STAT_RD__BMASK);
                                      // The data be written to FIFO within Transmit FIFO Request (TFRQ) service routines.
                                      break;
              
                              case I2C_ADDR_WR: // START+ADDR+W
                                      I2C0STAT &= ~(I2C0STAT_START__BMASK | I2C0STAT_WR__BMASK);
                                      break;
              
                              case I2C_RD_DATA:
                                      // Check for NACK
                                      if ((I2C0STAT & I2C0STAT_NACK__BMASK) == I2C0STAT_NACK__SET)
                                      {
                                              // Master did not NACK
                                              // Stopping transfer of data
                                              // Flush FIFO if there is data in it
                                              I2C0STAT &= ~I2C0STAT_NACK__BMASK;
                                      }
                                      I2C0STAT &= ~I2C0STAT_RD__BMASK;
                                      break;
              
                              case I2C_WR_DATA:  // FIFO is full, whatever slave ACK/NACK master
                                      I2C0STAT &= ~I2C0STAT_WR__BMASK;
                                      break;
              
                              case I2C_STOSTA:
                              case I2C_STOSTARD:
                                      I2C0STAT &= ~I2C0STAT_STOP__BMASK;
                                      txCnt = (I2C0FCT & I2C0FCT_TXCNT__FMASK) >> I2C0FCT_TXCNT__SHIFT;
                                      // One byte be shifted to the Shift register, also need to reload it.
                                      if(sendDataCnt > 2)
                                      {
                                              txCnt += 1;
                                      }
              
                                      if(txCnt > 0)
                                      {
                                              I2C0FCN0 |= I2C0FCN0_TFLSH__FLUSH;
                                              if(txCnt >= 2)
                                              {
                                                      I2C0DOUT = sendDataValue-txCnt;
                                                      I2C0DOUT = sendDataValue-txCnt+1;
                                                      sendDataValue = sendDataValue-(txCnt-2);
                                                      sendDataCnt = 2;
                                              }
                                              else if(txCnt == 1)
                                              {
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        12/30/2017 21:06:24 PAGE 9   

                                                      I2C0DOUT = sendDataValue-txCnt;
                                                      sendDataCnt = 1;
                                              }
                                      }
                                      //
                                      //      STOP Condition received.
                                      //
                                      return;         // START Flag set, so re-enter ISR
                                      break;
              
                              case I2C_STO:
                                      I2C0STAT &= ~I2C0STAT_STOP__BMASK;
                                      txCnt = (I2C0FCT & I2C0FCT_TXCNT__FMASK) >> I2C0FCT_TXCNT__SHIFT;
                                      // One byte be shifted to the Shift register, also need to reload it.
                                      if(sendDataCnt > 2)
                                      {
                                              txCnt += 1;
                                      }
              
                                      if(txCnt > 0)
                                      {
                                              I2C0FCN0 |= I2C0FCN0_TFLSH__FLUSH;
                                              if(txCnt >= 2)
                                              {
                                                      I2C0DOUT = sendDataValue-txCnt;
                                                      I2C0DOUT = sendDataValue-txCnt+1;
                                                      sendDataValue = sendDataValue-(txCnt-2);
                                                      sendDataCnt = 2;
                                              }
                                              else if(txCnt == 1)
                                              {
                                                      I2C0DOUT = sendDataValue-txCnt;
                                                      sendDataCnt = 1;
                                              }
                                      }
                                      //
                                      //      STOP Condition received.
                                      //
                                      break;
                              default:
                                      break;
                      }
              
                      // Clear I2C interrupt flag
                      I2C0STAT &= ~I2C0STAT_I2C0INT__BMASK;
              
              }
              
              
              #endif
 542          
 543          
 544          
 545          
 546          
 547          
 548          
 549          
 550          
 551          
 552          
 553          // SMBUS0_ISR
 554          //-----------------------------------------------------------------------------
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        12/30/2017 21:06:24 PAGE 10  

 555          //
 556          // SMBUS0 ISR Content goes here. Remember to clear flag bits:
 557          // SMB0CN0::SI (SMBus Interrupt Flag)
 558          //
 559          //-----------------------------------------------------------------------------
 560          SI_INTERRUPT (SMBUS0_ISR, SMBUS0_IRQn)
 561          {
 562   1              bool FAIL = 0;                       // Used by the ISR to flag failed
 563   1                                                                                       // transfers
 564   1      
 565   1              static uint8_t sent_byte_counter;
 566   1              static uint8_t rec_byte_counter;
 567   1      
 568   1              if (SMB0CN0_ARBLOST == 0)// Check for errors
 569   1              {
 570   2                      // Normal operation
 571   2                      switch (SMB0CN0 & 0xF0)// Status vector
 572   2                      {
 573   3                              // Master Transmitter/Receiver: START condition transmitted.
 574   3                              case SMB_MTSTA:
 575   3                              SMB0DAT = TARGET<<1;// Load address of the target slave
 576   3                              SMB0DAT &= 0xFE;// Clear the LSB of the address for the
 577   3                                                              // R/W bit
 578   3                              SMB0DAT |= (uint8_t) SMB_RW;// Load R/W bit
 579   3                              SMB0CN0_STA = 0;// Manually clear START bit
 580   3                              rec_byte_counter = 1;// Reset the counter
 581   3                              sent_byte_counter = 1;// Reset the counter
 582   3                              break;
 583   3      
 584   3                              // Master Transmitter: Data byte transmitted
 585   3                              case SMB_MTDB:
 586   3                              if (SMB0CN0_ACK)// Slave SMB0CN0_ACK?
 587   3                              {
 588   4                                      if (SMB_RW == WRITE)    // If this transfer is a WRITE,
 589   4                                      {
 590   5                                              if (sent_byte_counter <= nWR /*NUM_BYTES_WR*/)
 591   5                                              {
 592   6                                                      // send data byte
 593   6                                                      SMB0DAT = SMB_DATA_OUT[sent_byte_counter-1];
 594   6                                                      sent_byte_counter++;
 595   6                                              }
 596   5                                              else
 597   5                                              {
 598   6                                                      SMB0CN0_STO = 1; // Set SMB0CN0_STO to terminate transfer
 599   6                                                      SMB_BUSY = 0;// And free SMBus interface
 600   6                                              }
 601   5                                      }
 602   4                                      else {}                 // If this transfer is a READ,
 603   4                                                                                      // proceed with transfer without
 604   4                                                                                      // writing to SMB0DAT (switch
 605   4                                                                                      // to receive mode)
 606   4      
 607   4                              }
 608   3                              else                       // If slave NACK,
 609   3                              {
 610   4                                      SMB0CN0_STO = 1;        // Send STOP condition, followed
 611   4                                      SMB0CN0_STA = 1;// By a START
 612   4                                      NUM_ERRORS++;// Indicate error
 613   4                              }
 614   3                              break;
 615   3      
 616   3                              // Master Receiver: byte received
 617   3                              case SMB_MRDB:
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        12/30/2017 21:06:24 PAGE 11  

 618   3                              if (rec_byte_counter < NUM_BYTES_RD)
 619   3                              {
 620   4                                      SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT; // Store received
 621   4                                                                                                                         // byte
 622   4                                      SMB0CN0_ACK = 1;// Send SMB0CN0_ACK to indicate byte received
 623   4                                      rec_byte_counter++;// Increment the byte counter
 624   4                              }
 625   3                              else
 626   3                              {
 627   4                                      SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT; // Store received
 628   4                                                                                                                         // byte
 629   4                                      SMB_BUSY = 0;// Free SMBus interface
 630   4                                      SMB0CN0_ACK = 0;// Send NACK to indicate last byte
 631   4                                                                      // of this transfer
 632   4      
 633   4                                      SMB0CN0_STO = 1;// Send STOP to terminate transfer
 634   4                              }
 635   3                              break;
 636   3      
 637   3                              default:
 638   3                              FAIL = 1;                  // Indicate failed transfer
 639   3                                                                                 // and handle at end of ISR
 640   3                              break;
 641   3      
 642   3                      } // end switch
 643   2              }
 644   1              else
 645   1              {
 646   2                      // SMB0CN0_ARBLOST = 1, error occurred... abort transmission
 647   2                      FAIL = 1;
 648   2              } // end SMB0CN0_ARBLOST if
 649   1      
 650   1              if (FAIL)// If the transfer failed,
 651   1              {
 652   2                      SMB0CF &= ~0x80;                 // Reset communication
 653   2                      SMB0CF |= 0x80;
 654   2                      SMB0CN0_STA = 0;
 655   2                      SMB0CN0_STO = 0;
 656   2                      SMB0CN0_ACK = 0;
 657   2      
 658   2                      SMB_BUSY = 0;// Free SMBus
 659   2      
 660   2                      FAIL = 0;
 661   2                      LED1 = 0;
 662   2      
 663   2                      NUM_ERRORS++;// Indicate an error occurred
 664   2              }
 665   1      
 666   1              SMB0CN0_SI = 0;                     // Clear interrupt flag
 667   1      }
 668          
 669          //-----------------------------------------------------------------------------
 670          // TIMER3_ISR
 671          //-----------------------------------------------------------------------------
 672          //
 673          // TIMER3 ISR Content goes here. Remember to clear flag bits:
 674          // TMR3CN0::TF3H (Timer # High Byte Overflow Flag)
 675          // TMR3CN0::TF3L (Timer # Low Byte Overflow Flag)
 676          //
 677          //-----------------------------------------------------------------------------
 678          SI_INTERRUPT (TIMER3_ISR, TIMER3_IRQn)
 679          {
 680   1              SMB0CF &= ~0x80;                   // Disable SMBus
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        12/30/2017 21:06:24 PAGE 12  

 681   1              SMB0CF |= 0x80;// Re-enable SMBus
 682   1              TMR3CN0 &= ~0x80;// Clear Timer3 interrupt-pending
 683   1                                               // flag
 684   1              SMB0CN0_STA = 0;
 685   1              SMB_BUSY = 0;// Free SMBus
 686   1      }
 687          
 688          
 689          //-----------------------------------------------------------------------------
 690          // TIMER4_ISR
 691          //-----------------------------------------------------------------------------
 692          //
 693          // TIMER4 ISR Content goes here. Remember to clear flag bits:
 694          // TMR4CN0::TF4H (Timer # High Byte Overflow Flag)
 695          // TMR4CN0::TF4L (Timer # Low Byte Overflow Flag)
 696          //
 697          //-----------------------------------------------------------------------------
 698          SI_INTERRUPT (TIMER4_ISR, TIMER4_IRQn)
 699          {
 700   1              SFRPAGE = PG3_PAGE;
 701   1      
 702   1              I2C0CN0 &= ~I2C0CN0_I2C0EN__BMASK;                      // Disable I2C module
 703   1              I2C0CN0 |= I2C0CN0_I2C0EN__ENABLED;                     // Re-enable I2C module
 704   1      
 705   1              SFRPAGE = PG2_PAGE;
 706   1              TMR4CN0 &= ~TMR4CN0_TF4H__BMASK;                        // Clear Timer3 interrupt-pending flag
 707   1      
 708   1      }
 709          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    624    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    263    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
