C51 COMPILER V9.53.0.0   INTERRUPTS                                                        01/02/2018 16:56:29 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE INTERRUPTS
OBJECT MODULE PLACED IN .\src\Interrupts.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.53\BIN\C51.exe D:\WorkSpace\MyC
                    -ode\GE_EFM8LB12F64E-B-QFN32_YJ\GE_EFM8LB12F64E-B-QFN32_YJ\src\Interrupts.c OMF2 LARGE DEBUG OBJECTEXTEND ROM(LARGE) WARN
                    -INGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(D:\WorkSpace\MyCode\GE_E
                    -FM8LB12F64E-B-QFN32_YJ\GE_EFM8LB12F64E-B-QFN32_YJ\inc;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//Dev
                    -ice/shared/si8051base;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//Device/EFM8LB1/inc) PRINT(.\src\Int
                    -errupts.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\Interrupts.OBJ)

line level    source

   1          //=========================================================
   2          // src/Interrupts.c: generated by Hardware Configurator
   3          //
   4          // This file will be regenerated when saving a document.
   5          // leave the sections inside the "$[...]" comment tags alone
   6          // or they will be overwritten!!
   7          //=========================================================
   8          
   9          // USER INCLUDES
  10          #include <SI_EFM8LB1_Register_Enums.h>
  11          #include "EFM8LB1_SMBus_MasterMultibyte.h"
  12          #include "EFM8LB1_I2C_Slave.h"
  13          typedef enum {
  14                  SLAVE_NORMAL_DATA, SLAVE_DATA_ADDRESS,
  15          } SLAVE_WRITE_DATA_TYPE;
  16                  
  17          extern volatile uint8_t nWR;
  18          uint8_t arr_GBG[50]={0};
  19          uint8_t iArry = 0;
  20          
  21          
  22          #if 1//ø™∑≈æÕª·”∞œÏSMBUS0?         µ⁄“ª¥Œ≤‚ ‘ ±SMBUS0Õ£÷π¡À£®≤ªƒ‹»∑∂®£©£¨∫Û√Ê√ø¥Œ≤‚ ‘∂º «≥…π¶µƒ£¨SMBUS0∆µ¬
             - Œ™10.008KHZ,LED1∫√œÒ «≤ªƒ‹µ„¡¡¡À°£
  23          volatile uint8_t I2C1_slaveWriteData = 0x16;
  24          //const uint8_t cConst[10];
  25          #if 0
              uint8_t EEPROM_Buffer[3] = { 0, 1, 2 }; //[64] = { 0 };
              #else
  28          uint8_t EEPROM_Buffer[] =
  29          //uint8_t EEPROM_Buffer[] =
  30          {
  31                  17,             //B0
  32                  5,
  33                  6,
  34                  0,
  35                  0,
  36                  0,
  37                  0,
  38                  0,
  39                  0,
  40                  0,
  41                  0,
  42                  0,
  43                  0,
  44                  0,
  45                  0,
  46                  0,
  47                  0,
  48                  0,
  49                  0,
  50                  0,
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        01/02/2018 16:56:29 PAGE 2   

  51                  0,
  52                  0,
  53                  0,
  54                  0,
  55                  0,
  56                  0,
  57                  0,
  58                  0,
  59                  0,
  60                  0,
  61          
  62                  0,
  63                  0,
  64                  0,
  65                  0,
  66                  0,
  67                  0,
  68                  0,
  69                  0,
  70                  0,
  71                  0,
  72                  0,
  73                  0,
  74                  0,
  75                  0,
  76                  0,
  77                  0,
  78                  0,
  79                  0,
  80                  0,
  81                  0,
  82                  0,
  83                  0,
  84                  0,
  85                  0,
  86                  0,
  87                  0,
  88                  0,
  89                  0,
  90                  0,
  91                  0,
  92                  0,
  93                  0,
  94                  0,
  95                  0,
  96                  0,
  97                  0,
  98                  0,
  99                  0,
 100                  0,
 101                  0,
 102                  0,
 103                  0,
 104                  0,
 105                  0,
 106                  0,
 107                  0,
 108                  0,
 109                  0,
 110                  0,
 111                  0,
 112                  0,
 113                  0,
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        01/02/2018 16:56:29 PAGE 3   

 114                  0,
 115                  0,
 116                  0,
 117                  0,
 118                  0,
 119                  0,
 120                  0,
 121                  0,
 122                  0,
 123                  0,
 124                  0,
 125                  0,
 126                  0,
 127                  0,
 128                  0,
 129                  0,
 130                  0,
 131                  0,
 132                  0,
 133                  0,
 134                  0,
 135                  0,
 136                  0,
 137                  0,
 138                  0,
 139                  0,
 140                  0,
 141                  0,
 142                  56,
 143                  0,
 144                  0,
 145                  0,
 146                  0,
 147                  0,
 148                  0,
 149                  0,
 150                  0,
 151                  0,
 152                  0,
 153                  0,
 154                  0,
 155                  0,
 156                  0,
 157                  0,
 158                  0,
 159                  0,//B127
 160          
 161                  17,
 162                  0,
 163                  35,
 164                  128,//136
 165                  0,
 166                  112,
 167                  0,
 168                  0,
 169                  0,
 170                  0,
 171                  0,
 172                  0,
 173                  0,
 174                  0,
 175                  0,
 176                  0,
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        01/02/2018 16:56:29 PAGE 4   

 177                  0,
 178                  0,
 179                  1,
 180                  8,
 181                  70,
 182                  73,
 183                  84,
 184                  32,
 185                  0,
 186                  0,
 187                  0,
 188                  0,
 189                  0,
 190                  0,
 191                  0,
 192                  0,
 193                  0,
 194                  0,
 195                  0,
 196                  0,
 197                  31,
 198                  0,
 199                  9,
 200                  58,
 201                  49,
 202                  48,
 203                  48,
 204                  50,
 205                  57,
 206                  55,
 207                  49,
 208                  49,
 209                  48,
 210                  49,
 211                  32,
 212                  32,
 213                  32,
 214                  32,
 215                  32,
 216                  32,
 217                  49,
 218                  32,
 219                  66,
 220                  104,
 221                  7,
 222                  208,
 223                  0,
 224                  99,
 225                  2,//CR4=11 SR4=2 AOC=1?®∞24
 226                  0,
 227                  0,
 228                  0,
 229                  53,
 230                  50,
 231                  56,
 232                  54,
 233                  50,
 234                  48,
 235                  55,
 236                  53,
 237                  48,
 238                  32,
 239                  32,
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        01/02/2018 16:56:29 PAGE 5   

 240                  32,
 241                  32,
 242                  32,
 243                  32,
 244                  32,
 245                  49,
 246                  53,
 247                  49,
 248                  48,
 249                  49,
 250                  51,
 251                  32,
 252                  32,
 253                  0,
 254                  0,
 255                  0,
 256                  41,
 257          
 258                  0,
 259                  0,
 260                  0,
 261                  0,
 262                  0,
 263                  0,
 264                  0,
 265                  0,
 266                  0,
 267                  0,
 268                  0,
 269                  0,
 270                  0,
 271                  0,
 272                  0,
 273                  0,
 274                  0,
 275                  0,
 276                  0,
 277                  0,
 278                  0,
 279                  0,
 280                  0,
 281                  0,
 282                  0,
 283                  0,
 284                  0,
 285                  0,
 286                  0,
 287                  0,
 288                  0,
 289                  0,
 290          
 291          };
 292          #endif
 293          
 294          //-----------------------------------------------------------------------------
 295          // I2C0_ISR
 296          //-----------------------------------------------------------------------------
 297          //
 298          // I2C0 ISR Content goes here. Remember to clear flag bits:
 299          // I2C0STAT::I2C0INT (I2C Interrupt)
 300          //
 301          //-----------------------------------------------------------------------------
 302          SI_INTERRUPT (I2C0_ISR, I2C0_IRQn)
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        01/02/2018 16:56:29 PAGE 6   

 303          {
 304   1              static uint16_t eepromAddress = 0;  //for addressing larger than 256Byte
 305   1              static uint8_t slaveWriteType = SLAVE_NORMAL_DATA;
 306   1              static uint8_t WriteStat;
 307   1      
 308   1              switch (I2C0STAT & I2C_STATUS_VECTOR_MASK) {
 309   2      
 310   2                      case I2C_ADDR_RD:
 311   2                      I2C0STAT &= ~(I2C0STAT_START__BMASK | I2C0STAT_RD__BMASK);
 312   2                      I2C0DOUT = EEPROM_Buffer[eepromAddress++];
 313   2                      if(sizeof(EEPROM_Buffer) <= eepromAddress)
 314   2                      {
 315   3                              eepromAddress = 0;
 316   3                      }
 317   2                      break;
 318   2      
 319   2                      case I2C_ADDR_WR:
 320   2                      I2C0STAT &= ~(I2C0STAT_START__BMASK | I2C0STAT_WR__BMASK);
 321   2                      slaveWriteType = SLAVE_DATA_ADDRESS;
 322   2                      WriteStat = 1;
 323   2                      break;
 324   2      
 325   2                      case I2C_RD_DATA:
 326   2                      if ((I2C0STAT & I2C0STAT_NACK__BMASK) == I2C0STAT_NACK__SET) {
 327   3                              I2C0STAT &= ~I2C0STAT_NACK__BMASK;
 328   3                      } else {
 329   3                              I2C0DOUT = EEPROM_Buffer[eepromAddress++];
 330   3                              if(sizeof(EEPROM_Buffer) <= eepromAddress)
 331   3                              {
 332   4                                      eepromAddress = 0;
 333   4                              }
 334   3                      }
 335   2                      I2C0STAT &= ~I2C0STAT_RD__BMASK;
 336   2                      break;
 337   2      
 338   2                      case I2C_WR_DATA:
 339   2                      I2C0STAT &= ~I2C0STAT_WR__BMASK;
 340   2      
 341   2                      break;
 342   2      
 343   2                      case I2C_STOSTA:
 344   2                      case I2C_STOSTARD:
 345   2                      I2C0STAT &= ~I2C0STAT_STOP__BMASK;
 346   2                      return;
 347   2                      break;
 348   2      
 349   2                      case I2C_STO:
 350   2                      I2C0STAT &= ~I2C0STAT_STOP__BMASK;
 351   2                      break;
 352   2                      default:
 353   2                      break;
 354   2              }
 355   1      
 356   1              while((I2C0FCN1 & I2C0FCN1_RXE__BMASK) == I2C0FCN1_RXE__NOT_EMPTY) {
 357   2                      I2C1_slaveWriteData = I2C0DIN;
 358   2                      if(1==WriteStat&&80!=I2C1_slaveWriteData)
 359   2                      {
 360   3                              switch(slaveWriteType)
 361   3                              {
 362   4                                      case SLAVE_DATA_ADDRESS:
 363   4                                      if(I2C1_slaveWriteData>=128)
 364   4                                      {
 365   5                                              eepromAddress = I2C1_slaveWriteData+128*EEPROM_Buffer[127];
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        01/02/2018 16:56:29 PAGE 7   

 366   5                                      }
 367   4                                      else
 368   4                                      {
 369   5                                              eepromAddress = I2C1_slaveWriteData;
 370   5                                      }
 371   4                                      break;
 372   4      
 373   4                                      case SLAVE_NORMAL_DATA:
 374   4                                      default:
 375   4                                      EEPROM_Buffer[eepromAddress++] = I2C1_slaveWriteData;
 376   4      
 377   4                                      if(sizeof(EEPROM_Buffer) <= eepromAddress)
 378   4                                      {
 379   5                                              eepromAddress = 0;
 380   5                                      }
 381   4                                      break;
 382   4                              }
 383   3      
 384   3                              slaveWriteType = SLAVE_NORMAL_DATA;
 385   3                      }
 386   2              }
 387   1      
 388   1              I2C0STAT &= ~I2C0STAT_I2C0INT__BMASK;
 389   1      
 390   1      }
 391          #else
              
              //-----------------------------------------------------------------------------
              // I2C0_ISR
              //-----------------------------------------------------------------------------
              //
              // I2C0 ISR Content goes here. Remember to clear flag bits:
              // I2C0STAT::I2C0INT (I2C Interrupt)
              //
              //-----------------------------------------------------------------------------
              SI_INTERRUPT (I2C0_ISR, I2C0_IRQn)
              {
                      //  Number of bytes in the transmit FIFO and shift register
                      uint8_t txCnt = 0;
              
                      if((I2C0FCN1 & I2C0FCN1_TFRQ__BMASK) && (txDataReady == 1))
                      {
                              // Firmware fill the TX FIFO until the TX FIFO full, and it should
                              // locate at the beginning of the ISR, because the switch below may
                              // consume so much system cycle.
                              while((I2C0FCN1 & I2C0FCN1_TXNF__BMASK) == I2C0FCN1_TXNF__NOT_FULL)
                              {
                                      if ((I2C0STAT & I2C0STAT_NACK__BMASK) == I2C0STAT_NACK__SET)
                                      {
                                              // Master did not NACK
                                              // Stopping transfer of data
                                              // Flush FIFO if there is data in it
                                              I2C0STAT &= ~I2C0STAT_NACK__BMASK;
                                      }
                                      else
                                      {
                                              I2C0DOUT = sendDataValue++;
                                              sendDataCnt++;
                                      }
                              }
                              // The TFRQ will not set I2C0INT bit, so don't need to clear
                              // the I2C0INT when TFRQ happen.
                              // Other interrupts may be generated while dealing with the TFRQ,
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        01/02/2018 16:56:29 PAGE 8   

                              // so just return to avoid clearing other interrupts.
                              return;
                      }
              
                      if(I2C0FCN1 & I2C0FCN1_RFRQ__SET)
                      {
                              while((I2C0FCN1 & I2C0FCN1_RXE__BMASK) == I2C0FCN1_RXE__NOT_EMPTY)
                              { // Read data out
                                      i2cReceivedData   = I2C0DIN;
                                      // This example only supports host write 1 byte to slave
                                      // If want slave to accept more than 1 byte, use a buffer to save the data from FIFO
                                      dataReady = 1;
                              }
                              // Other interrupts may be generated while dealing with the RFRQ,
                              // so just return to avoid clearing other interrupts.
                              return;
                      }
              
                      switch (I2C0STAT & I2C_STATUS_VECTOR_MASK)
                      {
              
                              case I2C_ADDR_RD:  // START+ADDR+R
                                      I2C0STAT &= ~(I2C0STAT_START__BMASK | I2C0STAT_RD__BMASK);
                                      // The data be written to FIFO within Transmit FIFO Request (TFRQ) service routines.
                                      break;
              
                              case I2C_ADDR_WR: // START+ADDR+W
                                      I2C0STAT &= ~(I2C0STAT_START__BMASK | I2C0STAT_WR__BMASK);
                                      break;
              
                              case I2C_RD_DATA:
                                      // Check for NACK
                                      if ((I2C0STAT & I2C0STAT_NACK__BMASK) == I2C0STAT_NACK__SET)
                                      {
                                              // Master did not NACK
                                              // Stopping transfer of data
                                              // Flush FIFO if there is data in it
                                              I2C0STAT &= ~I2C0STAT_NACK__BMASK;
                                      }
                                      I2C0STAT &= ~I2C0STAT_RD__BMASK;
                                      break;
              
                              case I2C_WR_DATA:  // FIFO is full, whatever slave ACK/NACK master
                                      I2C0STAT &= ~I2C0STAT_WR__BMASK;
                                      break;
              
                              case I2C_STOSTA:
                              case I2C_STOSTARD:
                                      I2C0STAT &= ~I2C0STAT_STOP__BMASK;
                                      txCnt = (I2C0FCT & I2C0FCT_TXCNT__FMASK) >> I2C0FCT_TXCNT__SHIFT;
                                      // One byte be shifted to the Shift register, also need to reload it.
                                      if(sendDataCnt > 2)
                                      {
                                              txCnt += 1;
                                      }
              
                                      if(txCnt > 0)
                                      {
                                              I2C0FCN0 |= I2C0FCN0_TFLSH__FLUSH;
                                              if(txCnt >= 2)
                                              {
                                                      I2C0DOUT = sendDataValue-txCnt;
                                                      I2C0DOUT = sendDataValue-txCnt+1;
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        01/02/2018 16:56:29 PAGE 9   

                                                      sendDataValue = sendDataValue-(txCnt-2);
                                                      sendDataCnt = 2;
                                              }
                                              else if(txCnt == 1)
                                              {
                                                      I2C0DOUT = sendDataValue-txCnt;
                                                      sendDataCnt = 1;
                                              }
                                      }
                                      //
                                      //      STOP Condition received.
                                      //
                                      return;         // START Flag set, so re-enter ISR
                                      break;
              
                              case I2C_STO:
                                      I2C0STAT &= ~I2C0STAT_STOP__BMASK;
                                      txCnt = (I2C0FCT & I2C0FCT_TXCNT__FMASK) >> I2C0FCT_TXCNT__SHIFT;
                                      // One byte be shifted to the Shift register, also need to reload it.
                                      if(sendDataCnt > 2)
                                      {
                                              txCnt += 1;
                                      }
              
                                      if(txCnt > 0)
                                      {
                                              I2C0FCN0 |= I2C0FCN0_TFLSH__FLUSH;
                                              if(txCnt >= 2)
                                              {
                                                      I2C0DOUT = sendDataValue-txCnt;
                                                      I2C0DOUT = sendDataValue-txCnt+1;
                                                      sendDataValue = sendDataValue-(txCnt-2);
                                                      sendDataCnt = 2;
                                              }
                                              else if(txCnt == 1)
                                              {
                                                      I2C0DOUT = sendDataValue-txCnt;
                                                      sendDataCnt = 1;
                                              }
                                      }
                                      //
                                      //      STOP Condition received.
                                      //
                                      break;
                              default:
                                      break;
                      }
              
                      // Clear I2C interrupt flag
                      I2C0STAT &= ~I2C0STAT_I2C0INT__BMASK;
              
              }
              
              
              #endif
 547          
 548          
 549          
 550          
 551          
 552          
 553          
 554          
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        01/02/2018 16:56:29 PAGE 10  

 555          
 556          
 557          
 558          // SMBUS0_ISR
 559          //-----------------------------------------------------------------------------
 560          //
 561          // SMBUS0 ISR Content goes here. Remember to clear flag bits:
 562          // SMB0CN0::SI (SMBus Interrupt Flag)
 563          //
 564          //-----------------------------------------------------------------------------
 565          SI_INTERRUPT (SMBUS0_ISR, SMBUS0_IRQn)
 566          {
 567   1              bool FAIL = 0;                       // Used by the ISR to flag failed
 568   1                                                                                       // transfers
 569   1      
 570   1              static uint8_t sent_byte_counter;
 571   1              static uint8_t rec_byte_counter;
 572   1      
 573   1              if (SMB0CN0_ARBLOST == 0)// Check for errors
 574   1              {
 575   2                      // Normal operation
 576   2                      switch (SMB0CN0 & 0xF0)// Status vector
 577   2                      {
 578   3                              // Master Transmitter/Receiver: START condition transmitted.
 579   3                              case SMB_MTSTA:
 580   3                              SMB0DAT = TARGET<<1;// Load address of the target slave
 581   3                              SMB0DAT &= 0xFE;// Clear the LSB of the address for the
 582   3                                                              // R/W bit
 583   3                              SMB0DAT |= (uint8_t) SMB_RW;// Load R/W bit
 584   3                              SMB0CN0_STA = 0;// Manually clear START bit
 585   3                              rec_byte_counter = 1;// Reset the counter
 586   3                              sent_byte_counter = 1;// Reset the counter
 587   3                              break;
 588   3      
 589   3                              // Master Transmitter: Data byte transmitted
 590   3                              case SMB_MTDB:
 591   3                              if (SMB0CN0_ACK)// Slave SMB0CN0_ACK?
 592   3                              {
 593   4                                      if (SMB_RW == WRITE)    // If this transfer is a WRITE,
 594   4                                      {
 595   5                                              if (sent_byte_counter <= nWR /*NUM_BYTES_WR*/)
 596   5                                              {
 597   6                                                      // send data byte
 598   6                                                      SMB0DAT = SMB_DATA_OUT[sent_byte_counter-1];
 599   6                                                      sent_byte_counter++;
 600   6                                              }
 601   5                                              else
 602   5                                              {
 603   6                                                      SMB0CN0_STO = 1; // Set SMB0CN0_STO to terminate transfer
 604   6                                                      SMB_BUSY = 0;// And free SMBus interface
 605   6                                              }
 606   5      //                                      arr_GBG[iArry]={nWR};
 607   5      //                                      iArry++;
 608   5                                      }
 609   4                                      else {}                 // If this transfer is a READ,
 610   4                                                                                      // proceed with transfer without
 611   4                                                                                      // writing to SMB0DAT (switch
 612   4                                                                                      // to receive mode)
 613   4      
 614   4                              }
 615   3                              else                       // If slave NACK,
 616   3                              {
 617   4                                      SMB0CN0_STO = 1;        // Send STOP condition, followed
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        01/02/2018 16:56:29 PAGE 11  

 618   4                                      SMB0CN0_STA = 1;// By a START
 619   4                                      NUM_ERRORS++;// Indicate error
 620   4                              }
 621   3                              break;
 622   3      
 623   3                              // Master Receiver: byte received
 624   3                              case SMB_MRDB:
 625   3                              if (rec_byte_counter < NUM_BYTES_RD)
 626   3                              {
 627   4                                      SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT; // Store received
 628   4                                                                                                                         // byte
 629   4                                      SMB0CN0_ACK = 1;// Send SMB0CN0_ACK to indicate byte received
 630   4                                      rec_byte_counter++;// Increment the byte counter
 631   4                              }
 632   3                              else
 633   3                              {
 634   4                                      SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT; // Store received
 635   4                                                                                                                         // byte
 636   4                                      SMB_BUSY = 0;// Free SMBus interface
 637   4                                      SMB0CN0_ACK = 0;// Send NACK to indicate last byte
 638   4                                                                      // of this transfer
 639   4      
 640   4                                      SMB0CN0_STO = 1;// Send STOP to terminate transfer
 641   4                              }
 642   3                              break;
 643   3      
 644   3                              default:
 645   3                              FAIL = 1;                  // Indicate failed transfer
 646   3                                                                                 // and handle at end of ISR
 647   3                              break;
 648   3      
 649   3                      } // end switch
 650   2              }
 651   1              else
 652   1              {
 653   2                      // SMB0CN0_ARBLOST = 1, error occurred... abort transmission
 654   2                      FAIL = 1;
 655   2              } // end SMB0CN0_ARBLOST if
 656   1      
 657   1              if (FAIL)// If the transfer failed,
 658   1              {
 659   2                      SMB0CF &= ~0x80;                 // Reset communication
 660   2                      SMB0CF |= 0x80;
 661   2                      SMB0CN0_STA = 0;
 662   2                      SMB0CN0_STO = 0;
 663   2                      SMB0CN0_ACK = 0;
 664   2      
 665   2                      SMB_BUSY = 0;// Free SMBus
 666   2      
 667   2                      FAIL = 0;
 668   2                      LED1 = 0;
 669   2      
 670   2                      NUM_ERRORS++;// Indicate an error occurred
 671   2              }
 672   1      
 673   1              SMB0CN0_SI = 0;                     // Clear interrupt flag
 674   1      }
 675          
 676          //-----------------------------------------------------------------------------
 677          // TIMER3_ISR
 678          //-----------------------------------------------------------------------------
 679          //
 680          // TIMER3 ISR Content goes here. Remember to clear flag bits:
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        01/02/2018 16:56:29 PAGE 12  

 681          // TMR3CN0::TF3H (Timer # High Byte Overflow Flag)
 682          // TMR3CN0::TF3L (Timer # Low Byte Overflow Flag)
 683          //
 684          //-----------------------------------------------------------------------------
 685          SI_INTERRUPT (TIMER3_ISR, TIMER3_IRQn)
 686          {
 687   1              SMB0CF &= ~0x80;                   // Disable SMBus
 688   1              SMB0CF |= 0x80;// Re-enable SMBus
 689   1              TMR3CN0 &= ~0x80;// Clear Timer3 interrupt-pending
 690   1                                               // flag
 691   1              SMB0CN0_STA = 0;
 692   1              SMB_BUSY = 0;// Free SMBus
 693   1      }
 694          
 695          
 696          //-----------------------------------------------------------------------------
 697          // TIMER4_ISR
 698          //-----------------------------------------------------------------------------
 699          //
 700          // TIMER4 ISR Content goes here. Remember to clear flag bits:
 701          // TMR4CN0::TF4H (Timer # High Byte Overflow Flag)
 702          // TMR4CN0::TF4L (Timer # Low Byte Overflow Flag)
 703          //
 704          //-----------------------------------------------------------------------------
 705          SI_INTERRUPT (TIMER4_ISR, TIMER4_IRQn)
 706          {
 707   1              SFRPAGE = PG3_PAGE;
 708   1      
 709   1              I2C0CN0 &= ~I2C0CN0_I2C0EN__BMASK;                      // Disable I2C module
 710   1              I2C0CN0 |= I2C0CN0_I2C0EN__ENABLED;                     // Re-enable I2C module
 711   1      
 712   1              SFRPAGE = PG2_PAGE;
 713   1              TMR4CN0 &= ~TMR4CN0_TF4H__BMASK;                        // Clear Timer3 interrupt-pending flag
 714   1      
 715   1      }
 716          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    624    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    314    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
