C51 COMPILER V9.53.0.0   INTERRUPTS                                                        01/23/2018 14:43:33 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE INTERRUPTS
OBJECT MODULE PLACED IN .\src\Interrupts.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.53\BIN\C51.exe D:\WorkSpace\MyC
                    -ode\GE_EFM8LB12F64E-B-QFN32_YJ\GE_EFM8LB12F64E-B-QFN32_YJ\src\Interrupts.c OMF2 LARGE DEBUG OBJECTEXTEND ROM(LARGE) WARN
                    -INGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(D:\WorkSpace\MyCode\GE_E
                    -FM8LB12F64E-B-QFN32_YJ\GE_EFM8LB12F64E-B-QFN32_YJ\inc;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//Dev
                    -ice/shared/si8051base;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//Device/EFM8LB1/inc) PRINT(.\src\Int
                    -errupts.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\Interrupts.OBJ)

line level    source

   1          //=========================================================
   2          // src/Interrupts.c: generated by Hardware Configurator
   3          //
   4          // This file will be regenerated when saving a document.
   5          // leave the sections inside the "$[...]" comment tags alone
   6          // or they will be overwritten!!
   7          //=========================================================
   8          
   9          // USER INCLUDES
  10          #include <SI_EFM8LB1_Register_Enums.h>
  11          #include "EFM8LB1_SMBus_MasterMultibyte.h"
  12          #include "EFM8LB1_I2C_Slave.h"
  13          typedef enum {
  14                  SLAVE_NORMAL_DATA, SLAVE_DATA_ADDRESS,
  15          } SLAVE_WRITE_DATA_TYPE;
  16          
  17          extern volatile uint8_t nWR;
  18          extern uint32_t ADC_AVG;               // Accumulates the ADC samples
  19          extern bool CONV_COMPLETE;              // ADC accumulated result ready flag
  20          uint8_t iArry = 0;
  21          bool bTx_4th_byte_nack = false;
  22          
  23          //#if 1//ø™∑≈æÕª·”∞œÏSMBUS0?         µ⁄“ª¥Œ≤‚ ‘ ±SMBUS0Õ£÷π¡À£®≤ªƒ‹»∑∂®£©£¨∫Û√Ê√ø¥Œ≤‚ ‘∂º «≥…π¶µƒ£¨SMBUS0∆
             -µ¬ Œ™10.008KHZ,LED1∫√œÒ «≤ªƒ‹µ„¡¡¡À°£
  24          volatile uint8_t I2C1_slaveWriteData = 0x16;
  25          //const uint8_t cConst[10];
  26          #if 0
              uint8_t EEPROM_Buffer[3] = {0, 1, 2}; //[64] = { 0 };
              #else
  29          //pdata volatile static 
  30          uint8_t EEPROM_Buffer[] =
  31          //uint8_t EEPROM_Buffer[] =
  32                          {
  33                                          17,             //B0
  34                                          5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  35                                          0, 0, 0, 0, 0, 0, 0, 0,
  36          
  37                                          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  38                                          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  39                                          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  40                                          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 0, 0, 0,
  41                                          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  42                                          0,              //B127
  43          
  44                                          17, 0, 35,
  45                                          128,            //136
  46                                          0, 112, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 8, 70, 73, 84,
  47                                          32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 31, 0, 9, 58, 49, 48,
  48                                          48, 50, 57, 55, 49, 49, 48, 49, 32, 32, 32, 32, 32, 32, 49, 32,
  49                                          66, 104, 7, 208, 0, 99,
  50                                          2,              //CR4=11 SR4=2 AOC=1?®∞24
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        01/23/2018 14:43:33 PAGE 2   

  51                                          0, 0, 0, 53, 50, 56, 54, 50, 48, 55, 53, 48, 32, 32, 32, 32, 32,
  52                                          32, 32, 49, 53, 49, 48, 49, 51, 32, 32, 0, 0, 0, 41,
  53          
  54                                          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  55                                          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  56          
  57                          };
  58          #endif
  59          uint8_t dbg_Buffer[512]={0};
  60          static uint16_t k=0;
  61          //-----------------------------------------------------------------------------
  62          // I2C0_ISR
  63          //-----------------------------------------------------------------------------
  64          //
  65          // I2C0 ISR Content goes here. Remember to clear flag bits:
  66          // I2C0STAT::I2C0INT (I2C Interrupt)
  67          //
  68          //-----------------------------------------------------------------------------
  69          SI_INTERRUPT (I2C0_ISR, I2C0_IRQn)
  70          {
  71   1              static uint16_t eepromAddress = 0;  //for addressing larger than 256Byte
  72   1              static uint8_t slaveWriteType = SLAVE_NORMAL_DATA;
  73   1              static uint8_t WriteStat = 0;
  74   1              uint8_t t,j;
  75   1      
  76   1              uint8_t SAVE_SFRPAGE;
  77   1              bool EA_SAVE = IE_EA;                            // Preserve IE_EA
  78   1              IE_EA = 0;                                                      // Disable interrupts
  79   1              SAVE_SFRPAGE = SFRPAGE;
  80   1              SFRPAGE = 0x20;
  81   1      
  82   1              switch (I2C0STAT & I2C_STATUS_VECTOR_MASK) {
  83   2      
  84   2                      case I2C_ADDR_RD:
  85   2                      I2C0STAT &= ~(I2C0STAT_START__BMASK | I2C0STAT_RD__BMASK);
  86   2                      t = EEPROM_Buffer[eepromAddress++];
  87   2                      if(0x0==t)
  88   2                      {
  89   3                              j=t;
  90   3                      }
  91   2                      I2C0DOUT = t;//EEPROM_Buffer[eepromAddress++];
  92   2                      dbg_Buffer[k++]=t;
  93   2                      if(sizeof(EEPROM_Buffer) <= eepromAddress)
  94   2                      {
  95   3                              eepromAddress = 0;
  96   3                      }
  97   2                      WriteStat = 0;
  98   2                      break;
  99   2      
 100   2                      case I2C_ADDR_WR:
 101   2                      I2C0STAT &= ~(I2C0STAT_START__BMASK | I2C0STAT_WR__BMASK);
 102   2                      slaveWriteType = SLAVE_DATA_ADDRESS;
 103   2                      WriteStat = 1;
 104   2                      break;
 105   2      
 106   2                      case I2C_RD_DATA:
 107   2                      if ((I2C0STAT & I2C0STAT_NACK__BMASK) == I2C0STAT_NACK__SET) {
 108   3                              I2C0STAT &= ~I2C0STAT_NACK__BMASK;
 109   3                      } else {
 110   3                              t = EEPROM_Buffer[eepromAddress++];
 111   3                              if(0x11==t)
 112   3                              {
 113   4                                      j=t;
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        01/23/2018 14:43:33 PAGE 3   

 114   4                              }
 115   3                              I2C0DOUT = t;
 116   3                              dbg_Buffer[k++]=t;
 117   3      
 118   3                              if(sizeof(EEPROM_Buffer) <= eepromAddress)
 119   3                              {
 120   4                                      eepromAddress = 0;
 121   4                              }
 122   3                      }
 123   2                      I2C0STAT &= ~I2C0STAT_RD__BMASK;
 124   2                      break;
 125   2      
 126   2                      case I2C_WR_DATA:
 127   2                      I2C0STAT &= ~I2C0STAT_WR__BMASK;
 128   2      
 129   2                      break;
 130   2      
 131   2                      case I2C_STOSTA:
 132   2                      case I2C_STOSTARD:
 133   2                      I2C0STAT &= ~I2C0STAT_STOP__BMASK;
 134   2      #if 0
                              I2C0CN0 &= ~I2C0CN0_BUSY__BMASK;                // Clear BUSY bit
                              I2C0CN0 |= I2C0FCN0_RFLSH__FLUSH | I2C0FCN0_TFLSH__FLUSH;
              #endif
 138   2                      
 139   2      //              WriteStat = 0;//added 20180122
 140   2                      return;
 141   2                      break;
 142   2      
 143   2                      case I2C_STO:
 144   2                      I2C0STAT &= ~I2C0STAT_STOP__BMASK;
 145   2      #if 0
                              I2C0CN0 &= ~I2C0CN0_BUSY__BMASK;                // Clear BUSY bit
                              I2C0CN0 |= I2C0FCN0_RFLSH__FLUSH | I2C0FCN0_TFLSH__FLUSH;
              #endif
 149   2                      
 150   2      //              WriteStat = 0;//added 20180122
 151   2                      break;
 152   2                      default:
 153   2                      break;
 154   2              }
 155   1      
 156   1              while((I2C0FCN1 & I2C0FCN1_RXE__BMASK) == I2C0FCN1_RXE__NOT_EMPTY) {
 157   2                      I2C1_slaveWriteData = I2C0DIN;
 158   2                      if(1==WriteStat&&80!=I2C1_slaveWriteData)
 159   2                      {
 160   3                              switch(slaveWriteType)
 161   3                              {
 162   4                                      case SLAVE_DATA_ADDRESS:
 163   4                                      if(I2C1_slaveWriteData>=128)
 164   4                                      {
 165   5                                              eepromAddress = I2C1_slaveWriteData+128*EEPROM_Buffer[127];
 166   5                                      }
 167   4                                      else
 168   4                                      {
 169   5                                              eepromAddress = I2C1_slaveWriteData;
 170   5                                      }
 171   4                                      break;
 172   4      
 173   4                                      case SLAVE_NORMAL_DATA:
 174   4                                      default:
 175   4                                      EEPROM_Buffer[eepromAddress++] = I2C1_slaveWriteData;
 176   4      
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        01/23/2018 14:43:33 PAGE 4   

 177   4                                      if(sizeof(EEPROM_Buffer) <= eepromAddress)
 178   4                                      {
 179   5                                              eepromAddress = 0;
 180   5                                      }
 181   4                                      break;
 182   4                              }
 183   3      
 184   3                              slaveWriteType = SLAVE_NORMAL_DATA;
 185   3      //                      WriteStat = 0;//added 20180122
 186   3                      }
 187   2              }
 188   1      
 189   1              I2C0STAT &= ~I2C0STAT_I2C0INT__BMASK;
 190   1              SFRPAGE = SAVE_SFRPAGE;
 191   1              IE_EA = EA_SAVE;                                        // Restore interrupts
 192   1      
 193   1      }
 194          
 195          // SMBUS0_ISR
 196          //-----------------------------------------------------------------------------
 197          //
 198          // SMBUS0 ISR Content goes here. Remember to clear flag bits:
 199          // SMB0CN0::SI (SMBus Interrupt Flag)
 200          //
 201          //-----------------------------------------------------------------------------
 202          SI_INTERRUPT (SMBUS0_ISR, SMBUS0_IRQn)
 203          {
 204   1              bool FAIL = 0;                       // Used by the ISR to flag failed
 205   1                                                                                       // transfers
 206   1      
 207   1              static uint8_t sent_byte_counter;
 208   1              static uint8_t rec_byte_counter;
 209   1      
 210   1              if (SMB0CN0_ARBLOST == 0)                // Check for errors
 211   1              {
 212   2                      // Normal operation
 213   2                      switch (SMB0CN0 & 0xF0)// Status vector
 214   2                      {
 215   3                              // Master Transmitter/Receiver: START condition transmitted.
 216   3                              case SMB_MTSTA:
 217   3                              SMB0DAT = TARGET<<1;// Load address of the target slave
 218   3                              SMB0DAT &= 0xFE;        // Clear the LSB of the address for the
 219   3                                                                      // R/W bit
 220   3                              SMB0DAT |= (uint8_t) SMB_RW;// Load R/W bit
 221   3                              SMB0CN0_STA = 0;// Manually clear START bit
 222   3                              rec_byte_counter = 1;// Reset the counter
 223   3                              sent_byte_counter = 1;// Reset the counter
 224   3                              break;
 225   3      
 226   3                              // Master Transmitter: Data byte transmitted
 227   3                              case SMB_MTDB:
 228   3                              if (SMB0CN0_ACK)// Slave SMB0CN0_ACK?
 229   3                              {
 230   4                                      if (SMB_RW == WRITE)    // If this transfer is a WRITE,
 231   4                                      {
 232   5                                              if (sent_byte_counter <= nWR /*NUM_BYTES_WR*/)
 233   5                                              {
 234   6                                                      // send data byte
 235   6                                                      SMB0DAT = SMB_DATA_OUT[sent_byte_counter-1];
 236   6                                                      sent_byte_counter++;
 237   6                                              }
 238   5                                              else
 239   5                                              {
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        01/23/2018 14:43:33 PAGE 5   

 240   6                                                      SMB0CN0_STO = 1; // Set SMB0CN0_STO to terminate transfer
 241   6                                                      SMB_BUSY = 0;// And free SMBus interface
 242   6                                              }
 243   5                                      }
 244   4                                      else {}                 // If this transfer is a READ,
 245   4                                                                                      // proceed with transfer without
 246   4                                                                                      // writing to SMB0DAT (switch
 247   4                                                                                      // to receive mode)
 248   4      
 249   4                              }
 250   3                              else                       // If slave NACK,
 251   3                              {
 252   4                                      if(bTx_4th_byte_nack)
 253   4                                      {
 254   5                                              SMB0CN0_STO = 1; // Set SMB0CN0_STO to terminate transfer
 255   5                                              SMB_BUSY = 0;// And free SMBus interface
 256   5                                              break;
 257   5                                      }
 258   4                                      SMB0CN0_STO = 1;        // Send STOP condition, followed
 259   4                                      SMB0CN0_STA = 1;// By a START
 260   4                                      NUM_ERRORS++;// Indicate error
 261   4                              }
 262   3                              break;
 263   3      
 264   3                              // Master Receiver: byte received
 265   3                              case SMB_MRDB:
 266   3                              if (rec_byte_counter < NUM_BYTES_RD)
 267   3                              {
 268   4                                      SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT; // Store received
 269   4                                                                                                                         // byte
 270   4                                      SMB0CN0_ACK = 1;                                                   // Send SMB0CN0_ACK to indicate byte received
 271   4                                      rec_byte_counter++;                                                // Increment the byte counter
 272   4                              }
 273   3                              else
 274   3                              {
 275   4                                      SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT; // Store received
 276   4                                                                                                                         // byte
 277   4                                      SMB_BUSY = 0;                                                      // Free SMBus interface
 278   4                                      SMB0CN0_ACK = 0;                                                   // Send NACK to indicate last byte
 279   4                                                                                                                         // of this transfer
 280   4      
 281   4                                      SMB0CN0_STO = 1;                                                   // Send STOP to terminate transfer
 282   4                              }
 283   3                              break;
 284   3      
 285   3                              default:
 286   3                              FAIL = 1;                  // Indicate failed transfer
 287   3                                                                                 // and handle at end of ISR
 288   3                              break;
 289   3      
 290   3                      } // end switch
 291   2              }
 292   1              else
 293   1              {
 294   2                      // SMB0CN0_ARBLOST = 1, error occurred... abort transmission
 295   2                      FAIL = 1;
 296   2              } // end SMB0CN0_ARBLOST if
 297   1      
 298   1              if (FAIL)// If the transfer failed,
 299   1              {
 300   2                      SMB0CF &= ~0x80;                 // Reset communication
 301   2                      SMB0CF |= 0x80;
 302   2                      SMB0CN0_STA = 0;
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        01/23/2018 14:43:33 PAGE 6   

 303   2                      SMB0CN0_STO = 0;
 304   2                      SMB0CN0_ACK = 0;
 305   2      
 306   2                      SMB_BUSY = 0;// Free SMBus
 307   2      
 308   2                      FAIL = 0;
 309   2      //              LED1 = 0;
 310   2      
 311   2                      NUM_ERRORS++;// Indicate an error occurred
 312   2              }
 313   1      
 314   1              SMB0CN0_SI = 0;                     // Clear interrupt flag
 315   1      }
 316          
 317          //-----------------------------------------------------------------------------
 318          // TIMER3_ISR
 319          //-----------------------------------------------------------------------------
 320          //
 321          // TIMER3 ISR Content goes here. Remember to clear flag bits:
 322          // TMR3CN0::TF3H (Timer # High Byte Overflow Flag)
 323          // TMR3CN0::TF3L (Timer # Low Byte Overflow Flag)
 324          //
 325          //-----------------------------------------------------------------------------
 326          SI_INTERRUPT (TIMER3_ISR, TIMER3_IRQn)
 327          {
 328   1              SMB0CF &= ~0x80;                   // Disable SMBus
 329   1              SMB0CF |= 0x80;// Re-enable SMBus
 330   1              TMR3CN0 &= ~0x80;// Clear Timer3 interrupt-pending
 331   1                                         // flag
 332   1              SMB0CN0_STA = 0;
 333   1              SMB_BUSY = 0;  // Free SMBus
 334   1      }
 335          
 336          //-----------------------------------------------------------------------------
 337          // TIMER4_ISR
 338          //-----------------------------------------------------------------------------
 339          //
 340          // TIMER4 ISR Content goes here. Remember to clear flag bits:
 341          // TMR4CN0::TF4H (Timer # High Byte Overflow Flag)
 342          // TMR4CN0::TF4L (Timer # Low Byte Overflow Flag)
 343          //
 344          //-----------------------------------------------------------------------------
 345          SI_INTERRUPT (TIMER4_ISR, TIMER4_IRQn)
 346          {
 347   1              SFRPAGE = PG3_PAGE;
 348   1      
 349   1              I2C0CN0 &= ~I2C0CN0_I2C0EN__BMASK;                      // Disable I2C module
 350   1              I2C0CN0 |= I2C0CN0_I2C0EN__ENABLED;// Re-enable I2C module
 351   1      
 352   1              SFRPAGE = PG2_PAGE;
 353   1              TMR4CN0 &= ~TMR4CN0_TF4H__BMASK;// Clear Timer3 interrupt-pending flag
 354   1      
 355   1      }
 356          
 357          //-----------------------------------------------------------------------------
 358          // ADC0EOC_ISR
 359          //-----------------------------------------------------------------------------
 360          //
 361          // ADC0EOC ISR Content goes here. Remember to clear flag bits:
 362          // ADC0CN0::ADINT (Conversion Complete Interrupt Flag)
 363          //
 364          //-----------------------------------------------------------------------------
 365          SI_INTERRUPT (ADC0EOC_ISR, ADC0EOC_IRQn)
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        01/23/2018 14:43:33 PAGE 7   

 366          {
 367   1                 ADC0CN0_ADINT = 0;               // Clear ADC0 conv. complete flag
 368   1                 ADC_AVG = ADC0/4;
 369   1                 CONV_COMPLETE = 1;               // Set result ready flag
 370   1      
 371   1      }
 372          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    805    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    778    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       2
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
