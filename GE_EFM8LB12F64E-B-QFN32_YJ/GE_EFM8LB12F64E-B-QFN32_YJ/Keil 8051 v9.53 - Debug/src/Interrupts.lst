C51 COMPILER V9.53.0.0   INTERRUPTS                                                        12/30/2017 17:39:17 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE INTERRUPTS
OBJECT MODULE PLACED IN .\src\Interrupts.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.53\BIN\C51.exe D:\WorkSpace\MyC
                    -ode\GE_EFM8LB12F64E-B-QFN32_YJ\GE_EFM8LB12F64E-B-QFN32_YJ\src\Interrupts.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARN
                    -INGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(D:\WorkSpace\MyCode\GE_E
                    -FM8LB12F64E-B-QFN32_YJ\GE_EFM8LB12F64E-B-QFN32_YJ\inc;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//Dev
                    -ice/shared/si8051base;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//Device/EFM8LB1/inc) PRINT(.\src\Int
                    -errupts.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\Interrupts.OBJ)

line level    source

   1          //=========================================================
   2          // src/Interrupts.c: generated by Hardware Configurator
   3          //
   4          // This file will be regenerated when saving a document.
   5          // leave the sections inside the "$[...]" comment tags alone
   6          // or they will be overwritten!!
   7          //=========================================================
   8          
   9          // USER INCLUDES
  10          #include <SI_EFM8LB1_Register_Enums.h>
  11          #include "EFM8LB1_SMBus_MasterMultibyte.h"
  12          
  13          //-----------------------------------------------------------------------------
  14          // SMBUS0_ISR
  15          //-----------------------------------------------------------------------------
  16          //
  17          // SMBUS0 ISR Content goes here. Remember to clear flag bits:
  18          // SMB0CN0::SI (SMBus Interrupt Flag)
  19          //
  20          //-----------------------------------------------------------------------------
  21          SI_INTERRUPT (SMBUS0_ISR, SMBUS0_IRQn)
  22          {
  23   1         bool FAIL = 0;                       // Used by the ISR to flag failed
  24   1                                             // transfers
  25   1      
  26   1         static uint8_t sent_byte_counter;
  27   1         static uint8_t rec_byte_counter;
  28   1      
  29   1         if (SMB0CN0_ARBLOST == 0)           // Check for errors
  30   1         {
  31   2            // Normal operation
  32   2            switch (SMB0CN0 & 0xF0)          // Status vector
  33   2            {
  34   3               // Master Transmitter/Receiver: START condition transmitted.
  35   3               case SMB_MTSTA:
  36   3                  SMB0DAT = TARGET<<1;          // Load address of the target slave
  37   3                  SMB0DAT &= 0xFE;           // Clear the LSB of the address for the
  38   3                                             // R/W bit
  39   3                  SMB0DAT |= (uint8_t) SMB_RW;    // Load R/W bit
  40   3                  SMB0CN0_STA = 0;           // Manually clear START bit
  41   3                  rec_byte_counter = 1;      // Reset the counter
  42   3                  sent_byte_counter = 1;     // Reset the counter
  43   3                  break;
  44   3      
  45   3               // Master Transmitter: Data byte transmitted
  46   3               case SMB_MTDB:
  47   3                  if (SMB0CN0_ACK)           // Slave SMB0CN0_ACK?
  48   3                  {
  49   4                     if (SMB_RW == WRITE)    // If this transfer is a WRITE,
  50   4                     {
  51   5                                        if (sent_byte_counter <= nWR /*NUM_BYTES_WR*/)
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        12/30/2017 17:39:17 PAGE 2   

  52   5                        {
  53   6                           // send data byte
  54   6                           SMB0DAT = SMB_DATA_OUT[sent_byte_counter-1];
  55   6                           sent_byte_counter++;
  56   6                        }
  57   5                        else
  58   5                        {
  59   6                           SMB0CN0_STO = 1;  // Set SMB0CN0_STO to terminate transfer
  60   6                           SMB_BUSY = 0;     // And free SMBus interface
  61   6                        }
  62   5                     }
  63   4                     else {}                 // If this transfer is a READ,
  64   4                                             // proceed with transfer without
  65   4                                             // writing to SMB0DAT (switch
  66   4                                             // to receive mode)
  67   4      
  68   4                  }
  69   3                  else                       // If slave NACK,
  70   3                  {
  71   4                     SMB0CN0_STO = 1;        // Send STOP condition, followed
  72   4                     SMB0CN0_STA = 1;        // By a START
  73   4                     NUM_ERRORS++;           // Indicate error
  74   4                  }
  75   3                  break;
  76   3      
  77   3               // Master Receiver: byte received
  78   3               case SMB_MRDB:
  79   3                  if (rec_byte_counter < NUM_BYTES_RD)
  80   3                  {
  81   4                     SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT; // Store received
  82   4                                                                // byte
  83   4                     SMB0CN0_ACK = 1;        // Send SMB0CN0_ACK to indicate byte received
  84   4                     rec_byte_counter++;     // Increment the byte counter
  85   4                  }
  86   3                  else
  87   3                  {
  88   4                     SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT; // Store received
  89   4                                                                // byte
  90   4                     SMB_BUSY = 0;           // Free SMBus interface
  91   4                     SMB0CN0_ACK = 0;        // Send NACK to indicate last byte
  92   4                                             // of this transfer
  93   4      
  94   4                     SMB0CN0_STO = 1;        // Send STOP to terminate transfer
  95   4                  }
  96   3                  break;
  97   3      
  98   3               default:
  99   3                  FAIL = 1;                  // Indicate failed transfer
 100   3                                             // and handle at end of ISR
 101   3                  break;
 102   3      
 103   3            } // end switch
 104   2         }
 105   1         else
 106   1         {
 107   2            // SMB0CN0_ARBLOST = 1, error occurred... abort transmission
 108   2            FAIL = 1;
 109   2         } // end SMB0CN0_ARBLOST if
 110   1      
 111   1         if (FAIL)                           // If the transfer failed,
 112   1         {
 113   2            SMB0CF &= ~0x80;                 // Reset communication
 114   2            SMB0CF |= 0x80;
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        12/30/2017 17:39:17 PAGE 3   

 115   2            SMB0CN0_STA = 0;
 116   2            SMB0CN0_STO = 0;
 117   2            SMB0CN0_ACK = 0;
 118   2      
 119   2            SMB_BUSY = 0;                    // Free SMBus
 120   2      
 121   2            FAIL = 0;
 122   2            LED1 = 0;
 123   2      
 124   2            NUM_ERRORS++;                    // Indicate an error occurred
 125   2         }
 126   1      
 127   1         SMB0CN0_SI = 0;                     // Clear interrupt flag
 128   1      }
 129          
 130          //-----------------------------------------------------------------------------
 131          // TIMER3_ISR
 132          //-----------------------------------------------------------------------------
 133          //
 134          // TIMER3 ISR Content goes here. Remember to clear flag bits:
 135          // TMR3CN0::TF3H (Timer # High Byte Overflow Flag)
 136          // TMR3CN0::TF3L (Timer # Low Byte Overflow Flag)
 137          //
 138          //-----------------------------------------------------------------------------
 139          SI_INTERRUPT (TIMER3_ISR, TIMER3_IRQn)
 140          {
 141   1         SMB0CF  &= ~0x80;                   // Disable SMBus
 142   1         SMB0CF  |=  0x80;                   // Re-enable SMBus
 143   1         TMR3CN0 &= ~0x80;                   // Clear Timer3 interrupt-pending
 144   1                                             // flag
 145   1         SMB0CN0_STA = 0;
 146   1         SMB_BUSY = 0;                       // Free SMBus
 147   1      }
 148          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    197    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
