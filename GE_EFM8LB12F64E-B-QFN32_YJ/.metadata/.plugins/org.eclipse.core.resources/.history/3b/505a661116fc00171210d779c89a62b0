//=========================================================
// src/Interrupts.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!!
//=========================================================

// USER INCLUDES
#include <SI_EFM8LB1_Register_Enums.h>
#include "EFM8LB1_SMBus_MasterMultibyte.h"
#include "EFM8LB1_I2C_Slave.h"
typedef enum {
	SLAVE_NORMAL_DATA, SLAVE_DATA_ADDRESS,
} SLAVE_WRITE_DATA_TYPE;

extern volatile uint8_t nWR;
uint8_t arr_GBG[50] = { 0 };
uint8_t iArry = 0;
bool bTx_4th_byte_nack = false;

#if 1//开放就会影响SMBUS0?         第一次测试时SMBUS0停止了（不能确定），后面每次测试都是成功的，SMBUS0频率为10.008KHZ,LED1好像是不能点亮了。
volatile uint8_t I2C1_slaveWriteData = 0x16;
//const uint8_t cConst[10];
#if 0
uint8_t EEPROM_Buffer[3] = {0, 1, 2}; //[64] = { 0 };
#else
pdata uint8_t EEPROM_Buffer[] =
//uint8_t EEPROM_Buffer[] =
		{
				17,		//B0
				5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0,

				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0,		//B127

				17, 0, 35,
				128,		//136
				0, 112, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 8, 70, 73, 84,
				32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 31, 0, 9, 58, 49, 48,
				48, 50, 57, 55, 49, 49, 48, 49, 32, 32, 32, 32, 32, 32, 49, 32,
				66, 104, 7, 208, 0, 99,
				2,		//CR4=11 SR4=2 AOC=1?ò24
				0, 0, 0, 53, 50, 56, 54, 50, 48, 55, 53, 48, 32, 32, 32, 32, 32,
				32, 32, 49, 53, 49, 48, 49, 51, 32, 32, 0, 0, 0, 41,

				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

		};
#endif

//-----------------------------------------------------------------------------
// I2C0_ISR
//-----------------------------------------------------------------------------
//
// I2C0 ISR Content goes here. Remember to clear flag bits:
// I2C0STAT::I2C0INT (I2C Interrupt)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (I2C0_ISR, I2C0_IRQn)
{
	static uint16_t eepromAddress = 0;  //for addressing larger than 256Byte
	static uint8_t slaveWriteType = SLAVE_NORMAL_DATA;
	static uint8_t WriteStat;

	switch (I2C0STAT & I2C_STATUS_VECTOR_MASK) {

		case I2C_ADDR_RD:
		I2C0STAT &= ~(I2C0STAT_START__BMASK | I2C0STAT_RD__BMASK);
		I2C0DOUT = EEPROM_Buffer[eepromAddress++];
		if(sizeof(EEPROM_Buffer) <= eepromAddress)
		{
			eepromAddress = 0;
		}
		break;

		case I2C_ADDR_WR:
		I2C0STAT &= ~(I2C0STAT_START__BMASK | I2C0STAT_WR__BMASK);
		slaveWriteType = SLAVE_DATA_ADDRESS;
		WriteStat = 1;
		break;

		case I2C_RD_DATA:
		if ((I2C0STAT & I2C0STAT_NACK__BMASK) == I2C0STAT_NACK__SET) {
			I2C0STAT &= ~I2C0STAT_NACK__BMASK;
		} else {
			I2C0DOUT = EEPROM_Buffer[eepromAddress++];
			if(sizeof(EEPROM_Buffer) <= eepromAddress)
			{
				eepromAddress = 0;
			}
		}
		I2C0STAT &= ~I2C0STAT_RD__BMASK;
		break;

		case I2C_WR_DATA:
		I2C0STAT &= ~I2C0STAT_WR__BMASK;

		break;

		case I2C_STOSTA:
		case I2C_STOSTARD:
		I2C0STAT &= ~I2C0STAT_STOP__BMASK;
		return;
		break;

		case I2C_STO:
		I2C0STAT &= ~I2C0STAT_STOP__BMASK;
		break;
		default:
		break;
	}

	while((I2C0FCN1 & I2C0FCN1_RXE__BMASK) == I2C0FCN1_RXE__NOT_EMPTY) {
		I2C1_slaveWriteData = I2C0DIN;
		if(1==WriteStat&&80!=I2C1_slaveWriteData)
		{
			switch(slaveWriteType)
			{
				case SLAVE_DATA_ADDRESS:
				if(I2C1_slaveWriteData>=128)
				{
					eepromAddress = I2C1_slaveWriteData+128*EEPROM_Buffer[127];
				}
				else
				{
					eepromAddress = I2C1_slaveWriteData;
				}
				break;

				case SLAVE_NORMAL_DATA:
				default:
				EEPROM_Buffer[eepromAddress++] = I2C1_slaveWriteData;

				if(sizeof(EEPROM_Buffer) <= eepromAddress)
				{
					eepromAddress = 0;
				}
				break;
			}

			slaveWriteType = SLAVE_NORMAL_DATA;
		}
	}

	I2C0STAT &= ~I2C0STAT_I2C0INT__BMASK;

}
#else

//-----------------------------------------------------------------------------
// I2C0_ISR
//-----------------------------------------------------------------------------
//
// I2C0 ISR Content goes here. Remember to clear flag bits:
// I2C0STAT::I2C0INT (I2C Interrupt)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (I2C0_ISR, I2C0_IRQn)
{
	//  Number of bytes in the transmit FIFO and shift register
	uint8_t txCnt = 0;

	if((I2C0FCN1 & I2C0FCN1_TFRQ__BMASK) && (txDataReady == 1))
	{
		// Firmware fill the TX FIFO until the TX FIFO full, and it should
		// locate at the beginning of the ISR, because the switch below may
		// consume so much system cycle.
		while((I2C0FCN1 & I2C0FCN1_TXNF__BMASK) == I2C0FCN1_TXNF__NOT_FULL)
		{
			if ((I2C0STAT & I2C0STAT_NACK__BMASK) == I2C0STAT_NACK__SET)
			{
				// Master did not NACK
				// Stopping transfer of data
				// Flush FIFO if there is data in it
				I2C0STAT &= ~I2C0STAT_NACK__BMASK;
			}
			else
			{
				I2C0DOUT = sendDataValue++;
				sendDataCnt++;
			}
		}
		// The TFRQ will not set I2C0INT bit, so don't need to clear
		// the I2C0INT when TFRQ happen.
		// Other interrupts may be generated while dealing with the TFRQ,
		// so just return to avoid clearing other interrupts.
		return;
	}

	if(I2C0FCN1 & I2C0FCN1_RFRQ__SET)
	{
		while((I2C0FCN1 & I2C0FCN1_RXE__BMASK) == I2C0FCN1_RXE__NOT_EMPTY)
		{ // Read data out
			i2cReceivedData = I2C0DIN;
			// This example only supports host write 1 byte to slave
			// If want slave to accept more than 1 byte, use a buffer to save the data from FIFO
			dataReady = 1;
		}
		// Other interrupts may be generated while dealing with the RFRQ,
		// so just return to avoid clearing other interrupts.
		return;
	}

	switch (I2C0STAT & I2C_STATUS_VECTOR_MASK)
	{

		case I2C_ADDR_RD:  // START+ADDR+R
		I2C0STAT &= ~(I2C0STAT_START__BMASK | I2C0STAT_RD__BMASK);
		// The data be written to FIFO within Transmit FIFO Request (TFRQ) service routines.
		break;

		case I2C_ADDR_WR:// START+ADDR+W
		I2C0STAT &= ~(I2C0STAT_START__BMASK | I2C0STAT_WR__BMASK);
		break;

		case I2C_RD_DATA:
		// Check for NACK
		if ((I2C0STAT & I2C0STAT_NACK__BMASK) == I2C0STAT_NACK__SET)
		{
			// Master did not NACK
			// Stopping transfer of data
			// Flush FIFO if there is data in it
			I2C0STAT &= ~I2C0STAT_NACK__BMASK;
		}
		I2C0STAT &= ~I2C0STAT_RD__BMASK;
		break;

		case I2C_WR_DATA:  // FIFO is full, whatever slave ACK/NACK master
		I2C0STAT &= ~I2C0STAT_WR__BMASK;
		break;

		case I2C_STOSTA:
		case I2C_STOSTARD:
		I2C0STAT &= ~I2C0STAT_STOP__BMASK;
		txCnt = (I2C0FCT & I2C0FCT_TXCNT__FMASK) >> I2C0FCT_TXCNT__SHIFT;
		// One byte be shifted to the Shift register, also need to reload it.
		if(sendDataCnt > 2)
		{
			txCnt += 1;
		}

		if(txCnt > 0)
		{
			I2C0FCN0 |= I2C0FCN0_TFLSH__FLUSH;
			if(txCnt >= 2)
			{
				I2C0DOUT = sendDataValue-txCnt;
				I2C0DOUT = sendDataValue-txCnt+1;
				sendDataValue = sendDataValue-(txCnt-2);
				sendDataCnt = 2;
			}
			else if(txCnt == 1)
			{
				I2C0DOUT = sendDataValue-txCnt;
				sendDataCnt = 1;
			}
		}
		//
		//	STOP Condition received.
		//
		return;// START Flag set, so re-enter ISR
		break;

		case I2C_STO:
		I2C0STAT &= ~I2C0STAT_STOP__BMASK;
		txCnt = (I2C0FCT & I2C0FCT_TXCNT__FMASK) >> I2C0FCT_TXCNT__SHIFT;
		// One byte be shifted to the Shift register, also need to reload it.
		if(sendDataCnt > 2)
		{
			txCnt += 1;
		}

		if(txCnt > 0)
		{
			I2C0FCN0 |= I2C0FCN0_TFLSH__FLUSH;
			if(txCnt >= 2)
			{
				I2C0DOUT = sendDataValue-txCnt;
				I2C0DOUT = sendDataValue-txCnt+1;
				sendDataValue = sendDataValue-(txCnt-2);
				sendDataCnt = 2;
			}
			else if(txCnt == 1)
			{
				I2C0DOUT = sendDataValue-txCnt;
				sendDataCnt = 1;
			}
		}
		//
		//	STOP Condition received.
		//
		break;
		default:
		break;
	}

	// Clear I2C interrupt flag
	I2C0STAT &= ~I2C0STAT_I2C0INT__BMASK;

}

#endif

// SMBUS0_ISR
//-----------------------------------------------------------------------------
//
// SMBUS0 ISR Content goes here. Remember to clear flag bits:
// SMB0CN0::SI (SMBus Interrupt Flag)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (SMBUS0_ISR, SMBUS0_IRQn)
{
	bool FAIL = 0;                       // Used by the ISR to flag failed
										 // transfers

	static uint8_t sent_byte_counter;
	static uint8_t rec_byte_counter;

	if (SMB0CN0_ARBLOST == 0)		 // Check for errors
	{
		// Normal operation
		switch (SMB0CN0 & 0xF0)// Status vector
		{
			// Master Transmitter/Receiver: START condition transmitted.
			case SMB_MTSTA:
			SMB0DAT = TARGET<<1;// Load address of the target slave
			SMB0DAT &= 0xFE;	// Clear the LSB of the address for the
								// R/W bit
			SMB0DAT |= (uint8_t) SMB_RW;// Load R/W bit
			SMB0CN0_STA = 0;// Manually clear START bit
			rec_byte_counter = 1;// Reset the counter
			sent_byte_counter = 1;// Reset the counter
			break;

			// Master Transmitter: Data byte transmitted
			case SMB_MTDB:
			if (SMB0CN0_ACK)// Slave SMB0CN0_ACK?
			{
				if (SMB_RW == WRITE)    // If this transfer is a WRITE,
				{
					if (sent_byte_counter <= nWR /*NUM_BYTES_WR*/)
					{
						// send data byte
						SMB0DAT = SMB_DATA_OUT[sent_byte_counter-1];
						sent_byte_counter++;
					}
					else
					{
						SMB0CN0_STO = 1; // Set SMB0CN0_STO to terminate transfer
						SMB_BUSY = 0;// And free SMBus interface
					}
				}
				else {}                 // If this transfer is a READ,
										// proceed with transfer without
										// writing to SMB0DAT (switch
										// to receive mode)

			}
			else                       // If slave NACK,
			{
				if(bTx_4th_byte_nack)
				{
					SMB0CN0_STO = 1; // Set SMB0CN0_STO to terminate transfer
					SMB_BUSY = 0;// And free SMBus interface
					break;
				}
				SMB0CN0_STO = 1;        // Send STOP condition, followed
				SMB0CN0_STA = 1;// By a START
				NUM_ERRORS++;// Indicate error
			}
			break;

			// Master Receiver: byte received
			case SMB_MRDB:
			if (rec_byte_counter < NUM_BYTES_RD)
			{
				SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT; // Store received
														   // byte
				SMB0CN0_ACK = 1;						   // Send SMB0CN0_ACK to indicate byte received
				rec_byte_counter++;						   // Increment the byte counter
			}
			else
			{
				SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT; // Store received
														   // byte
				SMB_BUSY = 0;							   // Free SMBus interface
				SMB0CN0_ACK = 0;						   // Send NACK to indicate last byte
														   // of this transfer

				SMB0CN0_STO = 1;						   // Send STOP to terminate transfer
			}
			break;

			default:
			FAIL = 1;                  // Indicate failed transfer
									   // and handle at end of ISR
			break;

		} // end switch
	}
	else
	{
		// SMB0CN0_ARBLOST = 1, error occurred... abort transmission
		FAIL = 1;
	} // end SMB0CN0_ARBLOST if

	if (FAIL)// If the transfer failed,
	{
		SMB0CF &= ~0x80;                 // Reset communication
		SMB0CF |= 0x80;
		SMB0CN0_STA = 0;
		SMB0CN0_STO = 0;
		SMB0CN0_ACK = 0;

		SMB_BUSY = 0;// Free SMBus

		FAIL = 0;
//		LED1 = 0;

		NUM_ERRORS++;// Indicate an error occurred
	}

	SMB0CN0_SI = 0;                     // Clear interrupt flag
}

//-----------------------------------------------------------------------------
// TIMER3_ISR
//-----------------------------------------------------------------------------
//
// TIMER3 ISR Content goes here. Remember to clear flag bits:
// TMR3CN0::TF3H (Timer # High Byte Overflow Flag)
// TMR3CN0::TF3L (Timer # Low Byte Overflow Flag)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (TIMER3_ISR, TIMER3_IRQn)
{
	SMB0CF &= ~0x80;                   // Disable SMBus
	SMB0CF |= 0x80;// Re-enable SMBus
	TMR3CN0 &= ~0x80;// Clear Timer3 interrupt-pending
				   // flag
	SMB0CN0_STA = 0;
	SMB_BUSY = 0;  // Free SMBus
}

//-----------------------------------------------------------------------------
// TIMER4_ISR
//-----------------------------------------------------------------------------
//
// TIMER4 ISR Content goes here. Remember to clear flag bits:
// TMR4CN0::TF4H (Timer # High Byte Overflow Flag)
// TMR4CN0::TF4L (Timer # Low Byte Overflow Flag)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (TIMER4_ISR, TIMER4_IRQn)
{
	SFRPAGE = PG3_PAGE;

	I2C0CN0 &= ~I2C0CN0_I2C0EN__BMASK;			// Disable I2C module
	I2C0CN0 |= I2C0CN0_I2C0EN__ENABLED;// Re-enable I2C module

	SFRPAGE = PG2_PAGE;
	TMR4CN0 &= ~TMR4CN0_TF4H__BMASK;// Clear Timer3 interrupt-pending flag

}

//-----------------------------------------------------------------------------
// ADC0EOC_ISR
//-----------------------------------------------------------------------------
//
// ADC0EOC ISR Content goes here. Remember to clear flag bits:
// ADC0CN0::ADINT (Conversion Complete Interrupt Flag)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (ADC0EOC_ISR, ADC0EOC_IRQn)
{

}

