C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/29/2017 10:12:41 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE GE_EFM8LB12F64E_B_QFN32_YJ_MAIN
OBJECT MODULE PLACED IN .\src\GE_EFM8LB12F64E-B-QFN32_YJ_main.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.53\BIN\C51.exe D:\WorkSpace\MyC
                    -ode\SILICON_WORKSPACE\GE_EFM8LB12F64E-B-QFN32_YJ\src\GE_EFM8LB12F64E-B-QFN32_YJ_main.c OMF2 LARGE DEBUG OBJECTEXTEND ROM
                    -(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) BROWSE INTPROMOTE INCDIR(D:\Wo
                    -rkSpace\MyCode\SILICON_WORKSPACE\GE_EFM8LB12F64E-B-QFN32_YJ\inc;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v
                    -4.1.1//Device/shared/si8051base;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//Device/EFM8LB1/inc) PRINT
                    -(.\src\GE_EFM8LB12F64E-B-QFN32_YJ_main.lst) COND CODE PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\GE_EFM8LB12F64E-B-QFN32
                    -_YJ_main.OBJ)

line level    source

   1          //=========================================================
   2          // src/GE_EFM8LB12F64E-B-QFN32_YJ_main.c: generated by Hardware Configurator
   3          //
   4          // This file will be updated when saving a document.
   5          // leave the sections inside the "$[...]" comment tags alone
   6          // or they will be overwritten!!
   7          //=========================================================
   8          
   9          //-----------------------------------------------------------------------------
  10          // Includes
  11          //-----------------------------------------------------------------------------
  12          #include "bsp.h"
  13          #include "uart_1.h"
  14          #include "InitDevice.h"
  15          #include <stdio.h>
  16          
  17          #include <SI_EFM8LB1_Register_Enums.h>                  // SFR declarations
  18          #include "InitDevice.h"
  19          #include "EFM8LB1_I2C_Slave.h"
  20          #include "EFM8LB1_SMBus_MasterMultibyte.h"
  21          
  22          
  23          
  24          //#define TEST_I2C2
  25          
  26          
  27          // $[Generated Includes]
  28          // [Generated Includes]$
  29          //-----------------------------------------------------------------------------
  30          // Global Variables
  31          //-----------------------------------------------------------------------------
  32          uint8_t I2C_DATA[16];                      // Global holder for SMBus data.
  33          
  34          // All receive data is written
  35          // here;
  36          // all transmit data is read
  37          // from here
  38          
  39          //-----------------------------------------------------------------------------
  40          // Global Variables
  41          //-----------------------------------------------------------------------------
  42          // Global holder for SMBus data
  43          // All receive data is written here
  44          uint8_t SMB_DATA_IN[NUM_BYTES_RD];
  45          
  46          // Global holder for SMBus data.
  47          // All transmit data is read from here
  48          uint8_t SMB_DATA_OUT[NUM_BYTES_WR];
  49          
  50          uint8_t TARGET;                        // Target SMBus slave address
C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/29/2017 10:12:41 PAGE 2   

  51          
  52          volatile bool SMB_BUSY;                 // Software flag to indicate when the
  53          // SMB_Read() or SMB_Write() functions
  54          // have claimed the SMBus
  55          
  56          volatile bool SMB_RW;                   // Software flag to indicate the
  57          // direction of the current transfer
  58          
  59          uint16_t NUM_ERRORS;                   // Counter for the number of errors.
  60          volatile uint8_t nWR;
  61          
  62          bool DATA_READY = 0;                    // Set to '1' by the SMBus ISR
  63          // when a new data byte has been
  64          // received.
  65          
  66          //-----------------------------------------------------------------------------
  67          // SiLabs_Startup() Routine
  68          // ----------------------------------------------------------------------------
  69          // This function is called immediately after reset, before the initialization
  70          // code is run in SILABS_STARTUP.A51 (which runs before main() ). This is a
  71          // useful place to disable the watchdog timer, which is enable by default
  72          // and may trigger before main() in some instances.
  73          //-----------------------------------------------------------------------------
  74          void SiLabs_Startup(void) {
  75   1              // $[SiLabs Startup]
  76   1              // [SiLabs Startup]$
  77   1      }
  78          
  79          //-----------------------------------------------------------------------------
  80          // Function Prototypes
  81          //-----------------------------------------------------------------------------
  82          void SMB_Write(void);
  83          void SMB_Read(void);
  84          void T0_Waitms(uint8_t ms);
  85          
  86          bool SMB0_I2C_MasterWrite(uint16_t RegAddr, uint16_t RegValue) {
  87   1              nWR = 4;
  88   1              TARGET = TARGET_ADDR;                    // Target the Slave for next SMBus
  89   1              SMB_DATA_OUT[0] = (RegAddr >> 8) & 0xff;
  90   1              SMB_DATA_OUT[1] = RegAddr&0xff;
  91   1              SMB_DATA_OUT[2] = (RegValue >> 8) & 0xff;
  92   1              SMB_DATA_OUT[3] = RegValue&0xff;
  93   1              SMB_Write();                                     // Initiate SMBus write
  94   1              return 1;
  95   1      }
  96          
  97          uint16_t SMB0_I2C_MasterRead(uint16_t RegAddr) {
  98   1              uint16_t sRes;
  99   1              nWR = 2;
 100   1              TARGET = TARGET_ADDR;                    // Target the Slave for next SMBus
 101   1              SMB_DATA_OUT[0] = (RegAddr >> 8) & 0xff;
 102   1              SMB_DATA_OUT[1] = RegAddr&0xff;
 103   1              SMB_Write();                                     // Initiate SMBus write
 104   1              TARGET = TARGET_ADDR;
 105   1              SMB_Read();
 106   1              sRes = (SMB_DATA_IN[0] << 8) & 0xff00 | SMB_DATA_IN[1] & 0xff;
 107   1              return sRes;
 108   1      }
 109          
 110          
 111          #if 0
              //-----------------------------------------------------------------------------
              // main() Routine
C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/29/2017 10:12:41 PAGE 3   

              // ----------------------------------------------------------------------------
              int main(void) {
                      // Call hardware initialization routine
                      enter_DefaultMode_from_RESET();
              
                      DISP_EN = DISP_BC_DRIVEN;// EFM8 does not drive display
              
                      I2C_DATA[0] = 0xFD;// Initialize SMBus data holder
              
                      LED1 = 1;
                      while (1) {
              // $[Generated Run-time code]
              // [Generated Run-time code]$
                              IE_EA = 0;
                              SFRPAGE = PG3_PAGE;
                              I2C0CN0 &= ~I2C0CN0_BUSY__BMASK;// Clear BUSY bit
                              I2C0CN0 |= I2C0FCN0_RFLSH__FLUSH | I2C0FCN0_TFLSH__FLUSH;
                              IE_EA = 1;
              
                              while (!DATA_READY)
                              ;// New I2C data received?
                              DATA_READY = 0;
                              LED1 = !LED1;
              //              I2C_DATA = 0xff;
                      }
              }
              #else 
 141          //-----------------------------------------------------------------------------
 142          // Main Routine
 143          //-----------------------------------------------------------------------------
 144          //
 145          // Main routine performs all configuration tasks, then loops forever sending
 146          // and receiving SMBus data to the slave.
 147          //
 148          //-----------------------------------------------------------------------------
 149          void main(void) {
 150   1              volatile uint8_t dat;               // Test counter
 151   1              volatile uint8_t data_count;        // SMB_DATA_IN and SMB_DATA_OUT counter
 152   1              volatile uint8_t i;                          // Dummy variable counters
 153   1              volatile uint16_t sI2C_rd;
 154   1      
 155   1              enter_BusFreeMode_from_RESET();
 156   1      
 157   1              DISP_EN = DISP_BC_DRIVEN;           // EFM8 does not drive display
 158   1              I2C_DATA[0] = 0xFD;// Initialize SMBus data holder
 159   1      
 160   1              // If slave is holding SDA low because of an improper SMBus reset or error
 161   1              while (!SDA) {
 162   2                      // Provide clock pulses to allow the slave to advance out
 163   2                      // of its current state. This will allow it to release SDA.
 164   2                      XBR2 = XBR2_XBARE__ENABLED;             // Enable Crossbar
 165   2                      SCL = 0;                // Drive the clock low
 166   2                      for (i = 0; i < 255; i++)
 167   2                              ;               // Hold the clock low
 168   2                      SCL = 1;                // Release the clock
 169   2                      while (!SCL)
 170   2                              ;               // Wait for open-drain
 171   2                                              // clock output to rise
 172   2                      for (i = 0; i < 10; i++)
 173   2                              ;                                         // Hold the clock high
 174   2                      XBR2 = XBR2_XBARE__DISABLED;                                      // Disable Crossbar
 175   2              }
 176   1      
C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/29/2017 10:12:41 PAGE 4   

 177   1      
 178   1              
 179   1              enter_DefaultMode_from_RESET();
 180   1              DISP_EN = DISP_BC_DRIVEN;           // EFM8 does not drive display
 181   1              {
 182   2              // $[Generated Run-time code]
 183   2              // [Generated Run-time code]$
 184   2                              IE_EA = 0;
 185   2                              SFRPAGE = PG3_PAGE;
 186   2                              I2C0CN0 &= ~I2C0CN0_BUSY__BMASK;// Clear BUSY bit
 187   2                              I2C0CN0 |= I2C0FCN0_RFLSH__FLUSH | I2C0FCN0_TFLSH__FLUSH;
 188   2                              IE_EA = 1;
 189   2              
 190   2                              //while (!DATA_READY);// New I2C data received?
 191   2                              //DATA_READY = 0;
 192   2                              //LED1 = !LED1;
 193   2              //              I2C_DATA = 0xff;
 194   2              }
 195   1      
 196   1              UART1_initStdio(24500000, 115200);
 197   1              BSP_DISP_EN = BSP_DISP_BC_DRIVEN;       // Display not driven by EFM8
 198   1              BSP_BC_EN = BSP_BC_CONNECTED;           // Board controller connected to EFM8
 199   1      
 200   1              LED1 = LED_ON;
 201   1              SMB_BUSY = 0;                           //yj
 202   1              // TEST CODE----------------------------------------------------------------
 203   1      
 204   1              dat = 0;                            // Output data counter
 205   1              NUM_ERRORS = 0;                     // Error counter
 206   1              i = 0;
 207   1              while (1) {
 208   2                      sI2C_rd = 0;
 209   2                      printf("\r\n Start Test! ");
 210   2      
 211   2      #ifdef TEST_I2C2        
              #if 0
                              SMB_DATA_OUT[0] = 0;
                              SMB_DATA_OUT[1] = i;    //dat; // Define next outgoing byte
                              i = i;
                              TARGET = TARGET_ADDR;             // Target the Slave for next SMBus
                                                                                               // transfer
                              SMB_Write();                     // Initiate SMBus write
              
                              // SMBus Read Sequence
              //      TARGET = TARGET_ADDR;             // Target the Slave for next SMBus
                              // transfer
                              SMB_Read();
                              sI2C_rd = (SMB_DATA_IN[0] << 8) & 0xff00 | SMB_DATA_IN[1] & 0xff;
                              printf("\r\n SMB_DATA_IN: [0][1]->0x%02X ", sI2C_rd);
                              
                              if(i<16)
                                      i++;
                              else
                                      i = 0;
              #else
                              for(i=0;i<16;i++){
                                      sI2C_rd = SMB0_I2C_MasterRead(i);
                                      printf("\r\n SMB_DATA_IN: [0][1]->0x%02X ", sI2C_rd);
                                      if (NUM_ERRORS > 0) {
                                              LED1 = LED_OFF;
                                      } else {
                                              LED1 = !LED1;
                                      }
C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/29/2017 10:12:41 PAGE 5   

                                      T0_Waitms(1000);                                  // Wait 50 ms until the next cycle
                              }
              #endif
              #else
 244   2      //              SMB0_I2C_MasterWrite(0x9811,0xabcd);
 245   2      
 246   2                      sI2C_rd = SMB0_I2C_MasterRead(0x00);
 247   2      #if 1
 248   2      
 249   2                      sI2C_rd = sI2C_rd;
 250   2                      printf("\r\n SMB_DATA_IN: [0][1]->0x%02X ", sI2C_rd);
 251   2      
 252   2      
 253   2                      if(1==SMB0_I2C_MasterWrite(0x9811,0xabcd))
 254   2                      {
 255   3                              sI2C_rd = SMB0_I2C_MasterRead(0x9811);
 256   3                              if(0xabcd != sI2C_rd)
 257   3                                      printf("SMB0_I2C Write Error !!!");
 258   3                              printf("\r\n SMB_DATA_IN: [0][1]->0x%02X ", sI2C_rd);
 259   3                      }else
 260   2      #endif                  
 261   2                              printf("SMB0_I2C Write Failed !!!");
 262   2      #endif
 263   2                      // Indicate that an error has occurred (LED no longer lit)
 264   2                      if (NUM_ERRORS > 0) {
 265   3                              LED1 = LED_OFF;
 266   3                      } else {
 267   3                              LED1 = !LED1;
 268   3                      }
 269   2      
 270   2      
 271   2                      T0_Waitms(1000);                  // Wait 50 ms until the next cycle
 272   2                                                                                        // so that LED blinks slow enough to see
 273   2              }
 274   1      
 275   1      
 276   1              // END TEST CODE------------------------------------------------------------
 277   1      
 278   1      }
*** WARNING C280 IN LINE 151 OF D:\WorkSpace\MyCode\SILICON_WORKSPACE\GE_EFM8LB12F64E-B-QFN32_YJ\src\GE_EFM8LB12F64E-B-Q
             -FN32_YJ_main.c: 'data_count': unreferenced local variable
 279          #endif
 280          
 281          void SMB_Write(void) {
 282   1              while (SMB_BUSY)
 283   1                      ;                                  // Wait for SMBus to be free.
 284   1              SMB_BUSY = 1;                                      // Claim SMBus (set to busy)
 285   1              SMB_RW = 0;                                                // Mark this transfer as a WRITE
 286   1              SMB0CN0_STA = 1;                                   // Start transfer
 287   1      }
 288          
 289          //-----------------------------------------------------------------------------
 290          // SMB_Read
 291          //-----------------------------------------------------------------------------
 292          //
 293          // Return Value : None
 294          // Parameters   : None
 295          //
 296          // Reads a single byte from the slave with address specified by the <TARGET>
 297          // variable.
 298          // Calling sequence:
 299          // 1) Write target slave address to the <TARGET> variable
 300          // 2) Call SMB_Write()
C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/29/2017 10:12:41 PAGE 6   

 301          // 3) Read input data from <SMB_DATA_IN> variable array
 302          //
 303          //-----------------------------------------------------------------------------
 304          void SMB_Read(void) {
 305   1              while (SMB_BUSY)
 306   1                      ;                                  // Wait for bus to be free.
 307   1              SMB_BUSY = 1;                                      // Claim SMBus (set to busy)
 308   1              SMB_RW = 1;                                                // Mark this transfer as a READ
 309   1      
 310   1              SMB0CN0_STA = 1;                                   // Start transfer
 311   1      
 312   1              while (SMB_BUSY)
 313   1                      ;                                  // Wait for transfer to complete
 314   1      }
 315          
 316          //-----------------------------------------------------------------------------
 317          // T0_Waitms
 318          //-----------------------------------------------------------------------------
 319          //
 320          // Return Value : None
 321          // Parameters   :
 322          //   1) uint8_t ms - number of milliseconds to wait
 323          //                        range is full range of character: 0 to 255
 324          //
 325          // Configure Timer0 to wait for <ms> milliseconds using SYSCLK as its time
 326          // base.
 327          //
 328          //-----------------------------------------------------------------------------
 329          void T0_Waitms(uint8_t ms) {
 330   1              TCON &= ~0x30;                      // Stop Timer0; Clear TCON_TF0
 331   1              TMOD &= ~0x0f;                      // 16-bit free run mode
 332   1              TMOD |= 0x01;
 333   1      
 334   1              CKCON0 |= 0x04;                     // Timer0 counts SYSCLKs
 335   1      
 336   1              while (ms) {
 337   2                      TCON_TR0 = 0;                    // Stop Timer0
 338   2                      TH0 = ((-SYSCLK / 1000) >> 8);     // Overflow in 1ms
 339   2                      TL0 = ((-SYSCLK / 1000) & 0xFF);
 340   2                      TCON_TF0 = 0;                    // Clear overflow indicator
 341   2                      TCON_TR0 = 1;                    // Start Timer0
 342   2                      while (!TCON_TF0)
 343   2                              ;               // Wait for overflow
 344   2                      ms--;                            // Update ms counter
 345   2              }
 346   1      
 347   1              TCON_TR0 = 0;                       // Stop Timer0
 348   1      }
 349          
C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/29/2017 10:12:41 PAGE 7   

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION SiLabs_Startup (BEGIN)
                                           ; SOURCE LINE # 74
                                           ; SOURCE LINE # 77
0000 22                RET     
             ; FUNCTION SiLabs_Startup (END)

             ; FUNCTION _SMB0_I2C_MasterWrite (BEGIN)
                                           ; SOURCE LINE # 86
;---- Variable 'RegValue' assigned to Register 'R4/R5' ----
;---- Variable 'RegAddr' assigned to Register 'R2/R3' ----
0000 AB07              MOV     R3,AR7
0002 AA06              MOV     R2,AR6
                                           ; SOURCE LINE # 87
0004 900000      R     MOV     DPTR,#nWR
0007 7404              MOV     A,#04H
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 88
000A 900000      R     MOV     DPTR,#TARGET
000D 7410              MOV     A,#010H
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 89
0010 EA                MOV     A,R2
0011 900000      R     MOV     DPTR,#SMB_DATA_OUT
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 90
0015 EF                MOV     A,R7
0016 A3                INC     DPTR
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 91
0018 EC                MOV     A,R4
0019 A3                INC     DPTR
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 92
001B ED                MOV     A,R5
001C A3                INC     DPTR
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 93
001E 120000      R     LCALL   SMB_Write
                                           ; SOURCE LINE # 94
0021 D3                SETB    C
                                           ; SOURCE LINE # 95
0022         ?C0002:
0022 22                RET     
             ; FUNCTION _SMB0_I2C_MasterWrite (END)

             ; FUNCTION _SMB0_I2C_MasterRead (BEGIN)
                                           ; SOURCE LINE # 97
;---- Variable 'RegAddr' assigned to Register 'R4/R5' ----
0000 AD07              MOV     R5,AR7
0002 AC06              MOV     R4,AR6
                                           ; SOURCE LINE # 99
0004 900000      R     MOV     DPTR,#nWR
0007 7402              MOV     A,#02H
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 100
000A 900000      R     MOV     DPTR,#TARGET
000D 7410              MOV     A,#010H
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 101
0010 EC                MOV     A,R4
C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/29/2017 10:12:41 PAGE 8   

0011 900000      R     MOV     DPTR,#SMB_DATA_OUT
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 102
0015 EF                MOV     A,R7
0016 A3                INC     DPTR
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 103
0018 120000      R     LCALL   SMB_Write
                                           ; SOURCE LINE # 104
001B 900000      R     MOV     DPTR,#TARGET
001E 7410              MOV     A,#010H
0020 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 105
0021 120000      R     LCALL   SMB_Read
                                           ; SOURCE LINE # 106
0024 900000      R     MOV     DPTR,#SMB_DATA_IN
0027 E0                MOVX    A,@DPTR
0028 FE                MOV     R6,A
0029 A3                INC     DPTR
002A E0                MOVX    A,@DPTR
002B FD                MOV     R5,A
002C ED                MOV     A,R5
002D FF                MOV     R7,A
;---- Variable 'sRes' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 107
                                           ; SOURCE LINE # 108
002E         ?C0003:
002E 22                RET     
             ; FUNCTION _SMB0_I2C_MasterRead (END)

             ; FUNCTION main (BEGIN)
                                           ; SOURCE LINE # 149
                                           ; SOURCE LINE # 155
0000 120000      E     LCALL   enter_BusFreeMode_from_RESET
                                           ; SOURCE LINE # 157
0003 C2A3              CLR     DISP_EN
                                           ; SOURCE LINE # 158
0005 900000      R     MOV     DPTR,#I2C_DATA
0008 74FD              MOV     A,#0FDH
000A F0                MOVX    @DPTR,A
000B         ?C0004:
                                           ; SOURCE LINE # 161
000B 20922D            JB      SDA,?C0005
                                           ; SOURCE LINE # 164
000E 75E340            MOV     XBR2,#040H
                                           ; SOURCE LINE # 165
0011 C293              CLR     SCL
                                           ; SOURCE LINE # 166
0013 E4                CLR     A
0014 900000      R     MOV     DPTR,#i
0017 F0                MOVX    @DPTR,A
0018         ?C0006:
0018 900000      R     MOV     DPTR,#i
001B E0                MOVX    A,@DPTR
001C 04                INC     A
001D F0                MOVX    @DPTR,A
001E E0                MOVX    A,@DPTR
001F B4FFF6            CJNE    A,#0FFH,?C0006
0022         ?C0007:
                                           ; SOURCE LINE # 168
0022 D293              SETB    SCL
0024         ?C0009:
                                           ; SOURCE LINE # 169
C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/29/2017 10:12:41 PAGE 9   

0024 3093FD            JNB     SCL,?C0009
0027         ?C0010:
                                           ; SOURCE LINE # 172
0027 E4                CLR     A
0028 900000      R     MOV     DPTR,#i
002B F0                MOVX    @DPTR,A
002C         ?C0011:
002C 900000      R     MOV     DPTR,#i
002F E0                MOVX    A,@DPTR
0030 04                INC     A
0031 F0                MOVX    @DPTR,A
0032 E0                MOVX    A,@DPTR
0033 B40AF6            CJNE    A,#0AH,?C0011
0036         ?C0012:
                                           ; SOURCE LINE # 174
0036 E4                CLR     A
0037 F5E3              MOV     XBR2,A
                                           ; SOURCE LINE # 175
0039 80D0              SJMP    ?C0004
003B         ?C0005:
                                           ; SOURCE LINE # 179
003B 120000      E     LCALL   enter_DefaultMode_from_RESET
                                           ; SOURCE LINE # 180
003E C2A3              CLR     DISP_EN
                                           ; SOURCE LINE # 181
                                           ; SOURCE LINE # 184
0040 C2AF              CLR     IE_EA
                                           ; SOURCE LINE # 185
0042 75A720            MOV     SFRPAGE,#020H
                                           ; SOURCE LINE # 186
0045 53BAFE            ANL     I2C0CN0,#0FEH
                                           ; SOURCE LINE # 187
0048 43BA44            ORL     I2C0CN0,#044H
                                           ; SOURCE LINE # 188
004B D2AF              SETB    IE_EA
                                           ; SOURCE LINE # 194
                                           ; SOURCE LINE # 196
004D 900000      E     MOV     DPTR,#?_UART1_initStdio?BYTE+04H
0050 120000      E     LCALL   ?C?LSTKXDATA
0053 00                DB      00H
0054 01                DB      01H
0055 C2                DB      0C2H
0056 00                DB      00H
0057 7F20              MOV     R7,#020H
0059 7ED7              MOV     R6,#0D7H
005B 7D75              MOV     R5,#075H
005D 7C01              MOV     R4,#01H
005F 120000      E     LCALL   _UART1_initStdio
                                           ; SOURCE LINE # 197
0062 C2B4              CLR     BSP_DISP_EN
                                           ; SOURCE LINE # 198
0064 D2A2              SETB    BSP_BC_EN
                                           ; SOURCE LINE # 200
0066 C294              CLR     LED1
                                           ; SOURCE LINE # 201
0068 C200        R     CLR     SMB_BUSY
                                           ; SOURCE LINE # 204
006A E4                CLR     A
006B 900000      R     MOV     DPTR,#dat
006E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 205
006F 900000      R     MOV     DPTR,#NUM_ERRORS
0072 F0                MOVX    @DPTR,A
C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/29/2017 10:12:41 PAGE 10  

0073 A3                INC     DPTR
0074 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 206
0075 900000      R     MOV     DPTR,#i
0078 F0                MOVX    @DPTR,A
0079         ?C0014:
                                           ; SOURCE LINE # 207
                                           ; SOURCE LINE # 208
0079 E4                CLR     A
007A 900000      R     MOV     DPTR,#sI2C_rd
007D F0                MOVX    @DPTR,A
007E A3                INC     DPTR
007F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 209
0080 7BFF              MOV     R3,#0FFH
0082 7A00        R     MOV     R2,#HIGH ?SC_0
0084 7900        R     MOV     R1,#LOW ?SC_0
0086 120000      E     LCALL   _printf
                                           ; SOURCE LINE # 246
0089 E4                CLR     A
008A FF                MOV     R7,A
008B FE                MOV     R6,A
008C 120000      R     LCALL   _SMB0_I2C_MasterRead
008F 900000      R     MOV     DPTR,#sI2C_rd
0092 EE                MOV     A,R6
0093 F0                MOVX    @DPTR,A
0094 A3                INC     DPTR
0095 EF                MOV     A,R7
0096 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 249
0097 900000      R     MOV     DPTR,#sI2C_rd
009A E0                MOVX    A,@DPTR
009B FF                MOV     R7,A
009C A3                INC     DPTR
009D E0                MOVX    A,@DPTR
009E 900000      R     MOV     DPTR,#sI2C_rd
00A1 CF                XCH     A,R7
00A2 F0                MOVX    @DPTR,A
00A3 A3                INC     DPTR
00A4 EF                MOV     A,R7
00A5 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 250
00A6 7BFF              MOV     R3,#0FFH
00A8 7A00        R     MOV     R2,#HIGH ?SC_16
00AA 7900        R     MOV     R1,#LOW ?SC_16
00AC 900000      R     MOV     DPTR,#sI2C_rd
00AF E0                MOVX    A,@DPTR
00B0 FF                MOV     R7,A
00B1 A3                INC     DPTR
00B2 E0                MOVX    A,@DPTR
00B3 900000      E     MOV     DPTR,#?_printf?BYTE+03H
00B6 CF                XCH     A,R7
00B7 F0                MOVX    @DPTR,A
00B8 A3                INC     DPTR
00B9 EF                MOV     A,R7
00BA F0                MOVX    @DPTR,A
00BB 120000      E     LCALL   _printf
                                           ; SOURCE LINE # 253
00BE 7DCD              MOV     R5,#0CDH
00C0 7CAB              MOV     R4,#0ABH
00C2 7F11              MOV     R7,#011H
00C4 7E98              MOV     R6,#098H
00C6 120000      R     LCALL   _SMB0_I2C_MasterWrite
C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/29/2017 10:12:41 PAGE 11  

00C9 503D              JNC     ?C0016
                                           ; SOURCE LINE # 254
                                           ; SOURCE LINE # 255
00CB 7F11              MOV     R7,#011H
00CD 7E98              MOV     R6,#098H
00CF 120000      R     LCALL   _SMB0_I2C_MasterRead
00D2 900000      R     MOV     DPTR,#sI2C_rd
00D5 EE                MOV     A,R6
00D6 F0                MOVX    @DPTR,A
00D7 A3                INC     DPTR
00D8 EF                MOV     A,R7
00D9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 256
00DA 900000      R     MOV     DPTR,#sI2C_rd
00DD E0                MOVX    A,@DPTR
00DE 64AB              XRL     A,#0ABH
00E0 7004              JNZ     ?C0035
00E2 A3                INC     DPTR
00E3 E0                MOVX    A,@DPTR
00E4 64CD              XRL     A,#0CDH
00E6         ?C0035:
00E6 6009              JZ      ?C0017
                                           ; SOURCE LINE # 257
00E8 7BFF              MOV     R3,#0FFH
00EA 7A00        R     MOV     R2,#HIGH ?SC_48
00EC 7900        R     MOV     R1,#LOW ?SC_48
00EE 120000      E     LCALL   _printf
00F1         ?C0017:
                                           ; SOURCE LINE # 258
00F1 7BFF              MOV     R3,#0FFH
00F3 7A00        R     MOV     R2,#HIGH ?SC_16
00F5 7900        R     MOV     R1,#LOW ?SC_16
00F7 900000      R     MOV     DPTR,#sI2C_rd
00FA E0                MOVX    A,@DPTR
00FB FF                MOV     R7,A
00FC A3                INC     DPTR
00FD E0                MOVX    A,@DPTR
00FE 900000      E     MOV     DPTR,#?_printf?BYTE+03H
0101 CF                XCH     A,R7
0102 F0                MOVX    @DPTR,A
0103 A3                INC     DPTR
0104 EF                MOV     A,R7
0105 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 259
0106 8006              SJMP    ?C0036
0108         ?C0016:
                                           ; SOURCE LINE # 261
0108 7BFF              MOV     R3,#0FFH
010A 7A00        R     MOV     R2,#HIGH ?SC_73
010C 7900        R     MOV     R1,#LOW ?SC_73
010E         ?C0036:
010E 120000      E     LCALL   _printf
0111         ?C0018:
                                           ; SOURCE LINE # 264
0111 D3                SETB    C
0112 900000      R     MOV     DPTR,#NUM_ERRORS+01H
0115 E0                MOVX    A,@DPTR
0116 9400              SUBB    A,#00H
0118 900000      R     MOV     DPTR,#NUM_ERRORS
011B E0                MOVX    A,@DPTR
011C 9400              SUBB    A,#00H
011E 4004              JC      ?C0019
                                           ; SOURCE LINE # 265
C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/29/2017 10:12:41 PAGE 12  

0120 D294              SETB    LED1
                                           ; SOURCE LINE # 266
0122 8002              SJMP    ?C0020
0124         ?C0019:
                                           ; SOURCE LINE # 267
0124 B294              CPL     LED1
                                           ; SOURCE LINE # 268
0126         ?C0020:
                                           ; SOURCE LINE # 271
0126 7FE8              MOV     R7,#0E8H
0128 120000      R     LCALL   _T0_Waitms
                                           ; SOURCE LINE # 273
012B 020000      R     LJMP    ?C0014
             ; FUNCTION main (END)

             ; FUNCTION SMB_Write (BEGIN)
                                           ; SOURCE LINE # 281
0000         ?C0022:
                                           ; SOURCE LINE # 282
0000 2000FD            JB      SMB_BUSY,?C0022
0003         ?C0023:
                                           ; SOURCE LINE # 284
0003 D200        R     SETB    SMB_BUSY
                                           ; SOURCE LINE # 285
0005 C200        R     CLR     SMB_RW
                                           ; SOURCE LINE # 286
0007 D2C5              SETB    SMB0CN0_STA
                                           ; SOURCE LINE # 287
0009 22                RET     
             ; FUNCTION SMB_Write (END)

             ; FUNCTION SMB_Read (BEGIN)
                                           ; SOURCE LINE # 304
0000         ?C0025:
                                           ; SOURCE LINE # 305
0000 2000FD            JB      SMB_BUSY,?C0025
0003         ?C0026:
                                           ; SOURCE LINE # 307
0003 D200        R     SETB    SMB_BUSY
                                           ; SOURCE LINE # 308
0005 D200        R     SETB    SMB_RW
                                           ; SOURCE LINE # 310
0007 D2C5              SETB    SMB0CN0_STA
0009         ?C0027:
                                           ; SOURCE LINE # 312
0009 2000FD            JB      SMB_BUSY,?C0027
000C         ?C0028:
                                           ; SOURCE LINE # 314
000C         ?C0029:
000C 22                RET     
             ; FUNCTION SMB_Read (END)

             ; FUNCTION _T0_Waitms (BEGIN)
                                           ; SOURCE LINE # 329
;---- Variable 'ms' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 330
0000 5388CF            ANL     TCON,#0CFH
                                           ; SOURCE LINE # 331
0003 5389F0            ANL     TMOD,#0F0H
                                           ; SOURCE LINE # 332
0006 438901            ORL     TMOD,#01H
                                           ; SOURCE LINE # 334
0009 438E04            ORL     CKCON0,#04H
C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/29/2017 10:12:41 PAGE 13  

000C         ?C0030:
                                           ; SOURCE LINE # 336
000C EF                MOV     A,R7
000D 6012              JZ      ?C0031
                                           ; SOURCE LINE # 337
000F C28C              CLR     TCON_TR0
                                           ; SOURCE LINE # 338
0011 758CA0            MOV     TH0,#0A0H
                                           ; SOURCE LINE # 339
0014 758A4C            MOV     TL0,#04CH
                                           ; SOURCE LINE # 340
0017 C28D              CLR     TCON_TF0
                                           ; SOURCE LINE # 341
0019 D28C              SETB    TCON_TR0
001B         ?C0032:
                                           ; SOURCE LINE # 342
001B 308DFD            JNB     TCON_TF0,?C0032
001E         ?C0033:
                                           ; SOURCE LINE # 344
001E 1F                DEC     R7
                                           ; SOURCE LINE # 345
001F 80EB              SJMP    ?C0030
0021         ?C0031:
                                           ; SOURCE LINE # 347
0021 C28C              CLR     TCON_TR0
                                           ; SOURCE LINE # 348
0023 22                RET     
             ; FUNCTION _T0_Waitms (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    444    ----
   CONSTANT SIZE    =     99    ----
   XDATA SIZE       =     26       5
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
