C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/27/2017 18:02:00 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE GE_EFM8LB12F64E_B_QFN32_YJ_MAIN
OBJECT MODULE PLACED IN .\src\GE_EFM8LB12F64E-B-QFN32_YJ_main.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.53\BIN\C51.exe D:\WorkSpace\MyC
                    -ode\SILICON_WORKSPACE\GE_EFM8LB12F64E-B-QFN32_YJ\src\GE_EFM8LB12F64E-B-QFN32_YJ_main.c OMF2 LARGE DEBUG OBJECTEXTEND ROM
                    -(LARGE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(9,SPEED) DEFINE(NDEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(D:\WorkSpac
                    -e\MyCode\SILICON_WORKSPACE\GE_EFM8LB12F64E-B-QFN32_YJ\inc;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1/
                    -/Device/shared/si8051base;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//Device/EFM8LB1/inc) REGFILE(GE_
                    -EFM8LB12F64E-B-QFN32_YJ.ORC) PRINT(.\src\GE_EFM8LB12F64E-B-QFN32_YJ_main.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(
                    -.\src\GE_EFM8LB12F64E-B-QFN32_YJ_main.OBJ)

line level    source

   1          //=========================================================
   2          // src/GE_EFM8LB12F64E-B-QFN32_YJ_main.c: generated by Hardware Configurator
   3          //
   4          // This file will be updated when saving a document.
   5          // leave the sections inside the "$[...]" comment tags alone
   6          // or they will be overwritten!!
   7          //=========================================================
   8          
   9          //-----------------------------------------------------------------------------
  10          // Includes
  11          //-----------------------------------------------------------------------------
  12          #include "bsp.h"
  13          #include "uart_1.h"
  14          #include "InitDevice.h"
  15          #include <stdio.h>
  16          
  17          #include <SI_EFM8LB1_Register_Enums.h>                  // SFR declarations
  18          #include "InitDevice.h"
  19          #include "EFM8LB1_I2C_Slave.h"
  20          #include "EFM8LB1_SMBus_MasterMultibyte.h"
  21          
  22          // $[Generated Includes]
  23          // [Generated Includes]$
  24          //-----------------------------------------------------------------------------
  25          // Global Variables
  26          //-----------------------------------------------------------------------------
  27          uint8_t I2C_DATA[16];                      // Global holder for SMBus data.
  28          
  29          // All receive data is written
  30          // here;
  31          // all transmit data is read
  32          // from here
  33          
  34          //-----------------------------------------------------------------------------
  35          // Global Variables
  36          //-----------------------------------------------------------------------------
  37          // Global holder for SMBus data
  38          // All receive data is written here
  39          uint8_t SMB_DATA_IN[NUM_BYTES_RD];
  40          
  41          // Global holder for SMBus data.
  42          // All transmit data is read from here
  43          uint8_t SMB_DATA_OUT[NUM_BYTES_WR];
  44          
  45          uint8_t TARGET;                        // Target SMBus slave address
  46          
  47          volatile bool SMB_BUSY;                 // Software flag to indicate when the
  48          // SMB_Read() or SMB_Write() functions
  49          // have claimed the SMBus
  50          
C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/27/2017 18:02:00 PAGE 2   

  51          volatile bool SMB_RW;                   // Software flag to indicate the
  52          // direction of the current transfer
  53          
  54          uint16_t NUM_ERRORS;                   // Counter for the number of errors.
  55          
  56          bool DATA_READY = 0;                    // Set to '1' by the SMBus ISR
  57          // when a new data byte has been
  58          // received.
  59          
  60          //-----------------------------------------------------------------------------
  61          // SiLabs_Startup() Routine
  62          // ----------------------------------------------------------------------------
  63          // This function is called immediately after reset, before the initialization
  64          // code is run in SILABS_STARTUP.A51 (which runs before main() ). This is a
  65          // useful place to disable the watchdog timer, which is enable by default
  66          // and may trigger before main() in some instances.
  67          //-----------------------------------------------------------------------------
  68          void SiLabs_Startup(void) {
  69   1              // $[SiLabs Startup]
  70   1              // [SiLabs Startup]$
  71   1      }
  72          
  73          //-----------------------------------------------------------------------------
  74          // Function Prototypes
  75          //-----------------------------------------------------------------------------
  76          void SMB_Write(void);
  77          void SMB_Read(void);
  78          void T0_Waitms(uint8_t ms);
  79          
  80          #if 0
              //-----------------------------------------------------------------------------
              // main() Routine
              // ----------------------------------------------------------------------------
              int main(void) {
                      // Call hardware initialization routine
                      enter_DefaultMode_from_RESET();
              
                      DISP_EN = DISP_BC_DRIVEN;// EFM8 does not drive display
              
                      I2C_DATA[0] = 0xFD;// Initialize SMBus data holder
              
                      LED1 = 1;
                      while (1) {
              // $[Generated Run-time code]
              // [Generated Run-time code]$
                              IE_EA = 0;
                              SFRPAGE = PG3_PAGE;
                              I2C0CN0 &= ~I2C0CN0_BUSY__BMASK;// Clear BUSY bit
                              I2C0CN0 |= I2C0FCN0_RFLSH__FLUSH | I2C0FCN0_TFLSH__FLUSH;
                              IE_EA = 1;
              
                              while (!DATA_READY)
                              ;// New I2C data received?
                              DATA_READY = 0;
                              LED1 = !LED1;
              //              I2C_DATA = 0xff;
                      }
              }
              #else 
 110          //-----------------------------------------------------------------------------
 111          // Main Routine
 112          //-----------------------------------------------------------------------------
 113          //
C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/27/2017 18:02:00 PAGE 3   

 114          // Main routine performs all configuration tasks, then loops forever sending
 115          // and receiving SMBus data to the slave.
 116          //
 117          //-----------------------------------------------------------------------------
 118          void main(void) {
 119   1              volatile uint8_t dat;               // Test counter
 120   1              volatile uint8_t data_count;        // SMB_DATA_IN and SMB_DATA_OUT counter
 121   1              uint8_t i;                          // Dummy variable counters
 122   1              uint16_t sI2C_rd;
 123   1      #if 1
 124   1              enter_BusFreeMode_from_RESET();
 125   1      
 126   1              DISP_EN = DISP_BC_DRIVEN;           // EFM8 does not drive display
 127   1              I2C_DATA[0] = 0xFD;// Initialize SMBus data holder
 128   1      
 129   1              // If slave is holding SDA low because of an improper SMBus reset or error
 130   1              while (!SDA) {
 131   2                      // Provide clock pulses to allow the slave to advance out
 132   2                      // of its current state. This will allow it to release SDA.
 133   2                      XBR2 = XBR2_XBARE__ENABLED;             // Enable Crossbar
 134   2                      SCL = 0;                // Drive the clock low
 135   2                      for (i = 0; i < 255; i++)
 136   2                              ;               // Hold the clock low
 137   2                      SCL = 1;                // Release the clock
 138   2                      while (!SCL)
 139   2                              ;               // Wait for open-drain
 140   2                                              // clock output to rise
 141   2                      for (i = 0; i < 10; i++)
 142   2                              ;                                         // Hold the clock high
 143   2                      XBR2 = XBR2_XBARE__DISABLED;                                      // Disable Crossbar
 144   2              }
 145   1      #endif
 146   1              enter_DefaultMode_from_RESET();
 147   1              DISP_EN = DISP_BC_DRIVEN;           // EFM8 does not drive display
 148   1              {
 149   2              // $[Generated Run-time code]
 150   2              // [Generated Run-time code]$
 151   2                              IE_EA = 0;
 152   2                              SFRPAGE = PG3_PAGE;
 153   2                              I2C0CN0 &= ~I2C0CN0_BUSY__BMASK;// Clear BUSY bit
 154   2                              I2C0CN0 |= I2C0FCN0_RFLSH__FLUSH | I2C0FCN0_TFLSH__FLUSH;
 155   2                              IE_EA = 1;
 156   2              
 157   2                              //while (!DATA_READY);// New I2C data received?
 158   2                              //DATA_READY = 0;
 159   2                              //LED1 = !LED1;
 160   2              //              I2C_DATA = 0xff;
 161   2              }
 162   1      
 163   1              UART1_initStdio(24500000, 115200);
 164   1              BSP_DISP_EN = BSP_DISP_BC_DRIVEN;       // Display not driven by EFM8
 165   1              BSP_BC_EN = BSP_BC_CONNECTED;           // Board controller connected to EFM8
 166   1      
 167   1              LED1 = LED_ON;
 168   1              SMB_BUSY = 0;                           //yj
 169   1              // TEST CODE----------------------------------------------------------------
 170   1      
 171   1              dat = 0;                            // Output data counter
 172   1              NUM_ERRORS = 0;                     // Error counter
 173   1              while (1) {
 174   2                      sI2C_rd = 0;
 175   2                      printf("\r\n Start Test! ");
 176   2      #if 1
C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/27/2017 18:02:00 PAGE 4   

 177   2      
 178   2                      
 179   2                      SMB_DATA_OUT[0] = 0;
 180   2                      SMB_DATA_OUT[1] = i;    //dat; // Define next outgoing byte
 181   2      #endif    
 182   2                      i = i;
 183   2                      TARGET = SLAVE_ADDR;             // Target the Slave for next SMBus
 184   2                                                                                       // transfer
 185   2                      SMB_Write();                     // Initiate SMBus write
 186   2      
 187   2                      // SMBus Read Sequence
 188   2      //      TARGET = SLAVE_ADDR;             // Target the Slave for next SMBus
 189   2                      // transfer
 190   2                      SMB_Read();
 191   2      #if 0
                              // Check transfer data
                              for (data_count = 0; data_count < NUM_BYTES_RD; data_count++) {
              
                                      // Received data match transmit data?
                                      if (SMB_DATA_IN[data_count] != SMB_DATA_OUT[data_count]) {
              //            NUM_ERRORS++;              // Increment error counter if no
                                              // match
                                      }
                              }
              #endif
 202   2                      sI2C_rd = (SMB_DATA_IN[0] << 8) & 0xff00 | SMB_DATA_IN[1] & 0xff;
 203   2                      printf("\r\n SMB_DATA_IN: [0][1]->0x%02X ", sI2C_rd);
 204   2      
 205   2                      // Indicate that an error has occurred (LED no longer lit)
 206   2                      if (NUM_ERRORS > 0) {
 207   3                              LED1 = LED_OFF;
 208   3                      } else {
 209   3                              LED1 = !LED1;
 210   3                      }
 211   2      
 212   2                      // Run to here to view the SMB_DATA_IN and SMB_DATA_OUT variable arrays
 213   2                      if(i<16)
 214   2                              i++;
 215   2                      else
 216   2                              i = 0;
 217   2      
 218   2                      T0_Waitms(1000);                  // Wait 50 ms until the next cycle
 219   2                                                                                        // so that LED blinks slow enough to see
 220   2              }
 221   1              printf("\r\nEnter character: ");
 222   1      
 223   1              // END TEST CODE------------------------------------------------------------
 224   1      
 225   1      }
*** WARNING C280 IN LINE 120 OF D:\WorkSpace\MyCode\SILICON_WORKSPACE\GE_EFM8LB12F64E-B-QFN32_YJ\src\GE_EFM8LB12F64E-B-Q
             -FN32_YJ_main.c: 'data_count': unreferenced local variable
 226          #endif
 227          
 228          void SMB_Write(void) {
 229   1              while (SMB_BUSY)
 230   1                      ;                                  // Wait for SMBus to be free.
 231   1              SMB_BUSY = 1;                                      // Claim SMBus (set to busy)
 232   1              SMB_RW = 0;                                                // Mark this transfer as a WRITE
 233   1              SMB0CN0_STA = 1;                                   // Start transfer
 234   1      }
 235          
 236          //-----------------------------------------------------------------------------
 237          // SMB_Read
C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/27/2017 18:02:00 PAGE 5   

 238          //-----------------------------------------------------------------------------
 239          //
 240          // Return Value : None
 241          // Parameters   : None
 242          //
 243          // Reads a single byte from the slave with address specified by the <TARGET>
 244          // variable.
 245          // Calling sequence:
 246          // 1) Write target slave address to the <TARGET> variable
 247          // 2) Call SMB_Write()
 248          // 3) Read input data from <SMB_DATA_IN> variable array
 249          //
 250          //-----------------------------------------------------------------------------
 251          void SMB_Read(void) {
 252   1              while (SMB_BUSY)
 253   1                      ;                                  // Wait for bus to be free.
 254   1              SMB_BUSY = 1;                                      // Claim SMBus (set to busy)
 255   1              SMB_RW = 1;                                                // Mark this transfer as a READ
 256   1      
 257   1              SMB0CN0_STA = 1;                                   // Start transfer
 258   1      
 259   1              while (SMB_BUSY)
 260   1                      ;                                  // Wait for transfer to complete
 261   1      }
 262          
 263          //-----------------------------------------------------------------------------
 264          // T0_Waitms
 265          //-----------------------------------------------------------------------------
 266          //
 267          // Return Value : None
 268          // Parameters   :
 269          //   1) uint8_t ms - number of milliseconds to wait
 270          //                        range is full range of character: 0 to 255
 271          //
 272          // Configure Timer0 to wait for <ms> milliseconds using SYSCLK as its time
 273          // base.
 274          //
 275          //-----------------------------------------------------------------------------
 276          void T0_Waitms(uint8_t ms) {
 277   1              TCON &= ~0x30;                      // Stop Timer0; Clear TCON_TF0
 278   1              TMOD &= ~0x0f;                      // 16-bit free run mode
 279   1              TMOD |= 0x01;
 280   1      
 281   1              CKCON0 |= 0x04;                     // Timer0 counts SYSCLKs
 282   1      
 283   1              while (ms) {
 284   2                      TCON_TR0 = 0;                    // Stop Timer0
 285   2                      TH0 = ((-SYSCLK / 1000) >> 8);     // Overflow in 1ms
 286   2                      TL0 = ((-SYSCLK / 1000) & 0xFF);
 287   2                      TCON_TF0 = 0;                    // Clear overflow indicator
 288   2                      TCON_TR0 = 1;                    // Start Timer0
 289   2                      while (!TCON_TF0)
 290   2                              ;               // Wait for overflow
 291   2                      ms--;                            // Update ms counter
 292   2              }
 293   1      
 294   1              TCON_TR0 = 0;                       // Stop Timer0
 295   1      }
 296          
*** WARNING C294 IN LINE 221 OF D:\WorkSpace\MyCode\SILICON_WORKSPACE\GE_EFM8LB12F64E-B-QFN32_YJ\src\GE_EFM8LB12F64E-B-Q
             -FN32_YJ_main.c: unreachable code


C51 COMPILER V9.53.0.0   GE_EFM8LB12F64E_B_QFN32_YJ_MAIN                                   12/27/2017 18:02:00 PAGE 6   

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    292    ----
   CONSTANT SIZE    =     68    ----
   XDATA SIZE       =     23       3
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
