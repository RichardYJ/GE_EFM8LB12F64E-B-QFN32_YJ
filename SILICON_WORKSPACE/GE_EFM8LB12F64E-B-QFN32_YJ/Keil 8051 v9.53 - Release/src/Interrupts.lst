C51 COMPILER V9.53.0.0   INTERRUPTS                                                        12/27/2017 18:02:02 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE INTERRUPTS
OBJECT MODULE PLACED IN .\src\Interrupts.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.53\BIN\C51.exe D:\WorkSpace\MyC
                    -ode\SILICON_WORKSPACE\GE_EFM8LB12F64E-B-QFN32_YJ\src\Interrupts.c OMF2 LARGE DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(
                    -2) FLOATFUZZY(3) OPTIMIZE(9,SPEED) DEFINE(NDEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(D:\WorkSpace\MyCode\SILICON_WORK
                    -SPACE\GE_EFM8LB12F64E-B-QFN32_YJ\inc;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//Device/shared/si8051
                    -base;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.1.1//Device/EFM8LB1/inc) REGFILE(GE_EFM8LB12F64E-B-QFN32_
                    -YJ.ORC) PRINT(.\src\Interrupts.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\Interrupts.OBJ)

line level    source

   1          //=========================================================
   2          // src/Interrupts.c: generated by Hardware Configurator
   3          //
   4          // This file will be regenerated when saving a document.
   5          // leave the sections inside the "$[...]" comment tags alone
   6          // or they will be overwritten!!
   7          //=========================================================
   8          
   9          // USER INCLUDES
  10          #include <SI_EFM8LB1_Register_Enums.h>
  11          #include "EFM8LB1_I2C_Slave.h"
  12          #include "EFM8LB1_SMBus_MasterMultibyte.h"
  13          
  14          typedef enum {
  15                  SLAVE_NORMAL_DATA, SLAVE_DATA_ADDRESS,
  16          } SLAVE_WRITE_DATA_TYPE;
  17          
  18          volatile uint8_t I2C1_slaveWriteData = 0x16;
  19          //const uint8_t cConst[10];
  20          #if 0
              uint8_t EEPROM_Buffer[3] = { 0, 1, 2 }; //[64] = { 0 };
              #else
  23          uint8_t EEPROM_Buffer[] =
  24          //uint8_t EEPROM_Buffer[] =
  25          {
  26                  17,             //B0
  27                  5,
  28                  6,
  29                  0,
  30                  0,
  31                  0,
  32                  0,
  33                  0,
  34                  0,
  35                  0,
  36                  0,
  37                  0,
  38                  0,
  39                  0,
  40                  0,
  41                  0,
  42                  0,
  43                  0,
  44                  0,
  45                  0,
  46                  0,
  47                  0,
  48                  0,
  49                  0,
  50                  0,
  51                  0,
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        12/27/2017 18:02:02 PAGE 2   

  52                  0,
  53                  0,
  54                  0,
  55                  0,
  56          
  57                  0,
  58                  0,
  59                  0,
  60                  0,
  61                  0,
  62                  0,
  63                  0,
  64                  0,
  65                  0,
  66                  0,
  67                  0,
  68                  0,
  69                  0,
  70                  0,
  71                  0,
  72                  0,
  73                  0,
  74                  0,
  75                  0,
  76                  0,
  77                  0,
  78                  0,
  79                  0,
  80                  0,
  81                  0,
  82                  0,
  83                  0,
  84                  0,
  85                  0,
  86                  0,
  87                  0,
  88                  0,
  89                  0,
  90                  0,
  91                  0,
  92                  0,
  93                  0,
  94                  0,
  95                  0,
  96                  0,
  97                  0,
  98                  0,
  99                  0,
 100                  0,
 101                  0,
 102                  0,
 103                  0,
 104                  0,
 105                  0,
 106                  0,
 107                  0,
 108                  0,
 109                  0,
 110                  0,
 111                  0,
 112                  0,
 113                  0,
 114                  0,
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        12/27/2017 18:02:02 PAGE 3   

 115                  0,
 116                  0,
 117                  0,
 118                  0,
 119                  0,
 120                  0,
 121                  0,
 122                  0,
 123                  0,
 124                  0,
 125                  0,
 126                  0,
 127                  0,
 128                  0,
 129                  0,
 130                  0,
 131                  0,
 132                  0,
 133                  0,
 134                  0,
 135                  0,
 136                  0,
 137                  56,
 138                  0,
 139                  0,
 140                  0,
 141                  0,
 142                  0,
 143                  0,
 144                  0,
 145                  0,
 146                  0,
 147                  0,
 148                  0,
 149                  0,
 150                  0,
 151                  0,
 152                  0,
 153                  0,
 154                  0,//B127
 155          
 156                  17,
 157                  0,
 158                  35,
 159                  128,//136
 160                  0,
 161                  112,
 162                  0,
 163                  0,
 164                  0,
 165                  0,
 166                  0,
 167                  0,
 168                  0,
 169                  0,
 170                  0,
 171                  0,
 172                  0,
 173                  0,
 174                  1,
 175                  8,
 176                  70,
 177                  73,
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        12/27/2017 18:02:02 PAGE 4   

 178                  84,
 179                  32,
 180                  0,
 181                  0,
 182                  0,
 183                  0,
 184                  0,
 185                  0,
 186                  0,
 187                  0,
 188                  0,
 189                  0,
 190                  0,
 191                  0,
 192                  31,
 193                  0,
 194                  9,
 195                  58,
 196                  49,
 197                  48,
 198                  48,
 199                  50,
 200                  57,
 201                  55,
 202                  49,
 203                  49,
 204                  48,
 205                  49,
 206                  32,
 207                  32,
 208                  32,
 209                  32,
 210                  32,
 211                  32,
 212                  49,
 213                  32,
 214                  66,
 215                  104,
 216                  7,
 217                  208,
 218                  0,
 219                  99,
 220                  2,//CR4=11 SR4=2 AOC=1»ò24
 221                  0,
 222                  0,
 223                  0,
 224                  53,
 225                  50,
 226                  56,
 227                  54,
 228                  50,
 229                  48,
 230                  55,
 231                  53,
 232                  48,
 233                  32,
 234                  32,
 235                  32,
 236                  32,
 237                  32,
 238                  32,
 239                  32,
 240                  49,
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        12/27/2017 18:02:02 PAGE 5   

 241                  53,
 242                  49,
 243                  48,
 244                  49,
 245                  51,
 246                  32,
 247                  32,
 248                  0,
 249                  0,
 250                  0,
 251                  41,
 252          
 253                  0,
 254                  0,
 255                  0,
 256                  0,
 257                  0,
 258                  0,
 259                  0,
 260                  0,
 261                  0,
 262                  0,
 263                  0,
 264                  0,
 265                  0,
 266                  0,
 267                  0,
 268                  0,
 269                  0,
 270                  0,
 271                  0,
 272                  0,
 273                  0,
 274                  0,
 275                  0,
 276                  0,
 277                  0,
 278                  0,
 279                  0,
 280                  0,
 281                  0,
 282                  0,
 283                  0,
 284                  0,
 285          
 286          };
 287          #endif
 288          
 289          //-----------------------------------------------------------------------------
 290          // I2C0_ISR
 291          //-----------------------------------------------------------------------------
 292          //
 293          // I2C0 ISR Content goes here. Remember to clear flag bits:
 294          // I2C0STAT::I2C0INT (I2C Interrupt)
 295          //
 296          //-----------------------------------------------------------------------------
 297          SI_INTERRUPT (I2C0_ISR, I2C0_IRQn)
 298          {
 299   1              static uint16_t eepromAddress = 0;  //for addressing larger than 256Byte
 300   1              static uint8_t slaveWriteType = SLAVE_NORMAL_DATA;
 301   1              static uint8_t WriteStat;
 302   1      
 303   1              switch (I2C0STAT & I2C_STATUS_VECTOR_MASK) {
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        12/27/2017 18:02:02 PAGE 6   

 304   2      
 305   2                      case I2C_ADDR_RD:
 306   2                      I2C0STAT &= ~(I2C0STAT_START__BMASK | I2C0STAT_RD__BMASK);
 307   2                      I2C0DOUT = EEPROM_Buffer[eepromAddress++];
 308   2                      if(sizeof(EEPROM_Buffer) <= eepromAddress)
 309   2                      {
 310   3                              eepromAddress = 0;
 311   3                      }
 312   2                      break;
 313   2      
 314   2                      case I2C_ADDR_WR:
 315   2                      I2C0STAT &= ~(I2C0STAT_START__BMASK | I2C0STAT_WR__BMASK);
 316   2                      slaveWriteType = SLAVE_DATA_ADDRESS;
 317   2                      WriteStat = 1;
 318   2                      break;
 319   2      
 320   2                      case I2C_RD_DATA:
 321   2                      if ((I2C0STAT & I2C0STAT_NACK__BMASK) == I2C0STAT_NACK__SET) {
 322   3                              I2C0STAT &= ~I2C0STAT_NACK__BMASK;
 323   3                      } else {
 324   3                              I2C0DOUT = EEPROM_Buffer[eepromAddress++];
 325   3                              if(sizeof(EEPROM_Buffer) <= eepromAddress)
 326   3                              {
 327   4                                      eepromAddress = 0;
 328   4                              }
 329   3                      }
 330   2                      I2C0STAT &= ~I2C0STAT_RD__BMASK;
 331   2                      break;
 332   2      
 333   2                      case I2C_WR_DATA:
 334   2                      I2C0STAT &= ~I2C0STAT_WR__BMASK;
 335   2      
 336   2                      break;
 337   2      
 338   2                      case I2C_STOSTA:
 339   2                      case I2C_STOSTARD:
 340   2                      I2C0STAT &= ~I2C0STAT_STOP__BMASK;
 341   2                      return;
 342   2                      break;
 343   2      
 344   2                      case I2C_STO:
 345   2                      I2C0STAT &= ~I2C0STAT_STOP__BMASK;
 346   2                      break;
 347   2                      default:
 348   2                      break;
 349   2              }
 350   1      
 351   1              while((I2C0FCN1 & I2C0FCN1_RXE__BMASK) == I2C0FCN1_RXE__NOT_EMPTY) {
 352   2                      I2C1_slaveWriteData = I2C0DIN;
 353   2                      if(1==WriteStat&&80!=I2C1_slaveWriteData)
 354   2                      {
 355   3                              switch(slaveWriteType)
 356   3                              {
 357   4                                      case SLAVE_DATA_ADDRESS:
 358   4                                      if(I2C1_slaveWriteData>=128)
 359   4                                      {
 360   5                                              eepromAddress = I2C1_slaveWriteData+128*EEPROM_Buffer[127];
 361   5                                      }
 362   4                                      else
 363   4                                      {
 364   5                                              eepromAddress = I2C1_slaveWriteData;
 365   5                                      }
 366   4                                      break;
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        12/27/2017 18:02:02 PAGE 7   

 367   4      
 368   4                                      case SLAVE_NORMAL_DATA:
 369   4                                      default:
 370   4                                      EEPROM_Buffer[eepromAddress++] = I2C1_slaveWriteData;
 371   4      
 372   4                                      if(sizeof(EEPROM_Buffer) <= eepromAddress)
 373   4                                      {
 374   5                                              eepromAddress = 0;
 375   5                                      }
 376   4                                      break;
 377   4                              }
 378   3      
 379   3                              slaveWriteType = SLAVE_NORMAL_DATA;
 380   3                      }
 381   2              }
 382   1      
 383   1              I2C0STAT &= ~I2C0STAT_I2C0INT__BMASK;
 384   1      
 385   1      }
 386          
 387          //-----------------------------------------------------------------------------
 388          // TIMER4_ISR
 389          //-----------------------------------------------------------------------------
 390          //
 391          // TIMER4 ISR Content goes here. Remember to clear flag bits:
 392          // TMR4CN0::TF4H (Timer # High Byte Overflow Flag)
 393          // TMR4CN0::TF4L (Timer # Low Byte Overflow Flag)
 394          //
 395          //-----------------------------------------------------------------------------
 396          SI_INTERRUPT (TIMER4_ISR, TIMER4_IRQn)
 397          {
 398   1              SFRPAGE = PG3_PAGE;
 399   1      
 400   1              I2C0CN0 &= ~I2C0CN0_I2C0EN__BMASK;                      // Disable I2C module
 401   1              I2C0CN0 |= I2C0CN0_I2C0EN__ENABLED;// Re-enable I2C module
 402   1      
 403   1              SFRPAGE = PG2_PAGE;
 404   1              TMR4CN0 &= ~TMR4CN0_TF4H__BMASK;// Clear Timer3 interrupt-pending flag
 405   1      }
 406          
 407          //-----------------------------------------------------------------------------
 408          // SMBUS0_ISR
 409          //-----------------------------------------------------------------------------
 410          //
 411          // SMBUS0 ISR Content goes here. Remember to clear flag bits:
 412          // SMB0CN0::SI (SMBus Interrupt Flag)
 413          //
 414          //-----------------------------------------------------------------------------
 415          SI_INTERRUPT (SMBUS0_ISR, SMBUS0_IRQn)
 416          {
 417   1              bool FAIL = 0;                                          // Used by the ISR to flag failed
 418   1                                                                                      // transfers
 419   1      
 420   1              static uint8_t sent_byte_counter;
 421   1              static uint8_t rec_byte_counter;
 422   1      
 423   1              if (SMB0CN0_ARBLOST == 0)// Check for errors
 424   1              {
 425   2                      // Normal operation
 426   2                      switch (SMB0CN0 & 0xF0)// Status vector
 427   2                      {
 428   3                              // Master Transmitter/Receiver: START condition transmitted.
 429   3                              case SMB_MTSTA:
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        12/27/2017 18:02:02 PAGE 8   

 430   3                              SMB0DAT = TARGET<<1;// Load address of the target slave
 431   3                              SMB0DAT &= 0xFE;// Clear the LSB of the address for the
 432   3                                                              // R/W bit
 433   3                              SMB0DAT |= (uint8_t) SMB_RW;// Load R/W bit
 434   3                              SMB0CN0_STA = 0;// Manually clear START bit
 435   3                              rec_byte_counter = 1;// Reset the counter
 436   3                              sent_byte_counter = 1;// Reset the counter
 437   3                              break;
 438   3      
 439   3                              // Master Transmitter: Data byte transmitted
 440   3                              case SMB_MTDB:
 441   3                              if (SMB0CN0_ACK)// Slave SMB0CN0_ACK?
 442   3                              {
 443   4                                      if (SMB_RW == WRITE)    // If this transfer is a WRITE,
 444   4                                      {
 445   5                                              if (sent_byte_counter <= NUM_BYTES_WR)
 446   5                                              {
 447   6                                                      // send data byte
 448   6                                                      SMB0DAT = SMB_DATA_OUT[sent_byte_counter-1];
 449   6                                                      sent_byte_counter++;
 450   6                                              }
 451   5                                              else
 452   5                                              {
 453   6                                                      SMB0CN0_STO = 1; // Set SMB0CN0_STO to terminate transfer
 454   6                                                      SMB_BUSY = 0;// And free SMBus interface
 455   6                                              }
 456   5                                      }
 457   4                                      else {}                            // If this transfer is a READ,
 458   4                                                                                 // proceed with transfer without
 459   4                                                                                 // writing to SMB0DAT (switch
 460   4                                                                                 // to receive mode)
 461   4      
 462   4                              }
 463   3                              else                                       // If slave NACK,
 464   3                              {
 465   4                                      SMB0CN0_STO = 1;           // Send STOP condition, followed
 466   4                                      SMB0CN0_STA = 1;// By a START
 467   4                                      NUM_ERRORS++;// Indicate error
 468   4                              }
 469   3                              break;
 470   3      
 471   3                              // Master Receiver: byte received
 472   3                              case SMB_MRDB:
 473   3                              if (rec_byte_counter < NUM_BYTES_RD)
 474   3                              {
 475   4                                      SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT; // Store received
 476   4                                                                                                                         // byte
 477   4                                      SMB0CN0_ACK = 1;// Send SMB0CN0_ACK to indicate byte received
 478   4                                      rec_byte_counter++;// Increment the byte counter
 479   4                              }
 480   3                              else
 481   3                              {
 482   4                                      SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT; // Store received
 483   4                                                                                                                         // byte
 484   4                                      SMB_BUSY = 0;// Free SMBus interface
 485   4                                      SMB0CN0_ACK = 0;// Send NACK to indicate last byte
 486   4                                                                      // of this transfer
 487   4      
 488   4                                      SMB0CN0_STO = 1;// Send STOP to terminate transfer
 489   4                              }
 490   3                              break;
 491   3      
 492   3                              default:
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        12/27/2017 18:02:02 PAGE 9   

 493   3                              FAIL = 1;                                  // Indicate failed transfer
 494   3                                                                                 // and handle at end of ISR
 495   3                              break;
 496   3      
 497   3                      } // end switch
 498   2              }
 499   1              else
 500   1              {
 501   2                      // SMB0CN0_ARBLOST = 1, error occurred... abort transmission
 502   2                      FAIL = 1;
 503   2              } // end SMB0CN0_ARBLOST if
 504   1      
 505   1              if (FAIL)// If the transfer failed,
 506   1              {
 507   2                      SMB0CF &= ~0x80;                                   // Reset communication
 508   2                      SMB0CF |= 0x80;
 509   2                      SMB0CN0_STA = 0;
 510   2                      SMB0CN0_STO = 0;
 511   2                      SMB0CN0_ACK = 0;
 512   2      
 513   2                      SMB_BUSY = 0;// Free SMBus
 514   2      
 515   2                      FAIL = 0;
 516   2                      LED1 = 0;
 517   2      
 518   2                      NUM_ERRORS++;// Indicate an error occurred
 519   2              }
 520   1      
 521   1              SMB0CN0_SI = 0;                                    // Clear interrupt flag
 522   1      }
 523          
 524          //-----------------------------------------------------------------------------
 525          // TIMER3_ISR
 526          //-----------------------------------------------------------------------------
 527          //
 528          // TIMER3 ISR Content goes here. Remember to clear flag bits:
 529          // TMR3CN0::TF3H (Timer # High Byte Overflow Flag)
 530          // TMR3CN0::TF3L (Timer # Low Byte Overflow Flag)
 531          //
 532          //-----------------------------------------------------------------------------
 533          SI_INTERRUPT (TIMER3_ISR, TIMER3_IRQn)
 534          {
 535   1              SMB0CF &= ~0x80;                                   // Disable SMBus
 536   1              SMB0CF |= 0x80;// Re-enable SMBus
 537   1              TMR3CN0 &= ~0x80;// Clear Timer3 interrupt-pending
 538   1                                               // flag
 539   1              SMB0CN0_STA = 0;
 540   1              SMB_BUSY = 0;// Free SMBus
 541   1      }
 542          
 543          //-----------------------------------------------------------------------------
 544          // UART0_ISR
 545          //-----------------------------------------------------------------------------
 546          //
 547          // UART0 ISR Content goes here. Remember to clear flag bits:
 548          // SCON0::RI (Receive Interrupt Flag)
 549          // SCON0::TI (Transmit Interrupt Flag)
 550          //
 551          //-----------------------------------------------------------------------------
 552          SI_INTERRUPT (UART0_ISR, UART0_IRQn)
 553          {
 554   1      
 555   1      }
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        12/27/2017 18:02:02 PAGE 10  

 556          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    574    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    263    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
