//=========================================================
// src/GE_EFM8LB12F64E-B-QFN32_YJ_main.c: generated by Hardware Configurator
//
// This file will be updated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!!
//=========================================================

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include "bsp.h"
#include "uart_1.h"
#include "InitDevice.h"
#include <stdio.h>

#include <SI_EFM8LB1_Register_Enums.h>                  // SFR declarations
#include "InitDevice.h"
#include "EFM8LB1_I2C_Slave.h"
#include "EFM8LB1_SMBus_MasterMultibyte.h"

// $[Generated Includes]
// [Generated Includes]$
//-----------------------------------------------------------------------------
// Global Variables
//-----------------------------------------------------------------------------
uint8_t I2C_DATA[16];                      // Global holder for SMBus data.

// All receive data is written
// here;
// all transmit data is read
// from here

//-----------------------------------------------------------------------------
// Global Variables
//-----------------------------------------------------------------------------
// Global holder for SMBus data
// All receive data is written here
uint8_t SMB_DATA_IN[NUM_BYTES_RD];

// Global holder for SMBus data.
// All transmit data is read from here
uint8_t SMB_DATA_OUT[NUM_BYTES_WR];

uint8_t TARGET;                        // Target SMBus slave address

volatile bool SMB_BUSY;                 // Software flag to indicate when the
// SMB_Read() or SMB_Write() functions
// have claimed the SMBus

volatile bool SMB_RW;                   // Software flag to indicate the
// direction of the current transfer

uint16_t NUM_ERRORS;                   // Counter for the number of errors.

bool DATA_READY = 0;                    // Set to '1' by the SMBus ISR
// when a new data byte has been
// received.

//-----------------------------------------------------------------------------
// SiLabs_Startup() Routine
// ----------------------------------------------------------------------------
// This function is called immediately after reset, before the initialization
// code is run in SILABS_STARTUP.A51 (which runs before main() ). This is a
// useful place to disable the watchdog timer, which is enable by default
// and may trigger before main() in some instances.
//-----------------------------------------------------------------------------
void SiLabs_Startup(void) {
	// $[SiLabs Startup]
	// [SiLabs Startup]$
}

//-----------------------------------------------------------------------------
// Function Prototypes
//-----------------------------------------------------------------------------
void SMB_Write(void);
void SMB_Read(void);
void T0_Waitms(uint8_t ms);

#if 0
//-----------------------------------------------------------------------------
// main() Routine
// ----------------------------------------------------------------------------
int main(void) {
	// Call hardware initialization routine
	enter_DefaultMode_from_RESET();

	DISP_EN = DISP_BC_DRIVEN;// EFM8 does not drive display

	I2C_DATA[0] = 0xFD;// Initialize SMBus data holder

	LED1 = 1;
	while (1) {
// $[Generated Run-time code]
// [Generated Run-time code]$
		IE_EA = 0;
		SFRPAGE = PG3_PAGE;
		I2C0CN0 &= ~I2C0CN0_BUSY__BMASK;// Clear BUSY bit
		I2C0CN0 |= I2C0FCN0_RFLSH__FLUSH | I2C0FCN0_TFLSH__FLUSH;
		IE_EA = 1;

		while (!DATA_READY)
		;// New I2C data received?
		DATA_READY = 0;
		LED1 = !LED1;
//		I2C_DATA = 0xff;
	}
}
#else 
//-----------------------------------------------------------------------------
// Main Routine
//-----------------------------------------------------------------------------
//
// Main routine performs all configuration tasks, then loops forever sending
// and receiving SMBus data to the slave.
//
//-----------------------------------------------------------------------------
void main(void) {
	volatile uint8_t dat;               // Test counter
	volatile uint8_t data_count;        // SMB_DATA_IN and SMB_DATA_OUT counter
	uint8_t i;                          // Dummy variable counters
	uint16_t sI2C_rd;
#if 1
	enter_BusFreeMode_from_RESET();

	DISP_EN = DISP_BC_DRIVEN;           // EFM8 does not drive display
	I2C_DATA[0] = 0xFD;// Initialize SMBus data holder

	// If slave is holding SDA low because of an improper SMBus reset or error
	while (!SDA) {
		// Provide clock pulses to allow the slave to advance out
		// of its current state. This will allow it to release SDA.
		XBR2 = XBR2_XBARE__ENABLED;		// Enable Crossbar
		SCL = 0;		// Drive the clock low
		for (i = 0; i < 255; i++)
			;		// Hold the clock low
		SCL = 1;		// Release the clock
		while (!SCL)
			;		// Wait for open-drain
					// clock output to rise
		for (i = 0; i < 10; i++)
			;					  // Hold the clock high
		XBR2 = XBR2_XBARE__DISABLED;					  // Disable Crossbar
	}
#endif
	enter_DefaultMode_from_RESET();
	DISP_EN = DISP_BC_DRIVEN;           // EFM8 does not drive display
	{
			IE_EA = 0;
			SFRPAGE = PG3_PAGE;
			I2C0CN0 &= ~I2C0CN0_BUSY__BMASK;// Clear BUSY bit
			I2C0CN0 |= I2C0FCN0_RFLSH__FLUSH | I2C0FCN0_TFLSH__FLUSH;
			IE_EA = 1;
	
			//while (!DATA_READY);// New I2C data received?
			//DATA_READY = 0;
			//LED1 = !LED1;
	//		I2C_DATA = 0xff;
	}

	UART1_initStdio(24500000, 115200);
	BSP_DISP_EN = BSP_DISP_BC_DRIVEN;	// Display not driven by EFM8
	BSP_BC_EN = BSP_BC_CONNECTED;		// Board controller connected to EFM8

	LED1 = LED_ON;
	SMB_BUSY = 0;				//yj
	// TEST CODE----------------------------------------------------------------

	dat = 0;                            // Output data counter
	NUM_ERRORS = 0;                     // Error counter
	while (1) {
		sI2C_rd = 0;
		printf("\r\n Start Test! ");
#if 1

		
		SMB_DATA_OUT[0] = 0;
		SMB_DATA_OUT[1] = i;	//dat; // Define next outgoing byte
#endif	  
		i = i;
		TARGET = SLAVE_ADDR;             // Target the Slave for next SMBus
										 // transfer
		SMB_Write();                     // Initiate SMBus write

		// SMBus Read Sequence
//      TARGET = SLAVE_ADDR;             // Target the Slave for next SMBus
		// transfer
		SMB_Read();
#if 0
		// Check transfer data
		for (data_count = 0; data_count < NUM_BYTES_RD; data_count++) {

			// Received data match transmit data?
			if (SMB_DATA_IN[data_count] != SMB_DATA_OUT[data_count]) {
//            NUM_ERRORS++;              // Increment error counter if no
				// match
			}
		}
#endif
		sI2C_rd = (SMB_DATA_IN[0] << 8) & 0xff00 | SMB_DATA_IN[1] & 0xff;
		printf("\r\n SMB_DATA_IN: [0][1]->0x%02X ", sI2C_rd);

		// Indicate that an error has occurred (LED no longer lit)
		if (NUM_ERRORS > 0) {
			LED1 = LED_OFF;
		} else {
			LED1 = !LED1;
		}

		// Run to here to view the SMB_DATA_IN and SMB_DATA_OUT variable arrays
		if(i<16)
			i++;
		else
			i = 0;

		T0_Waitms(1000);                  // Wait 50 ms until the next cycle
										  // so that LED blinks slow enough to see
	}
	printf("\r\nEnter character: ");

	// END TEST CODE------------------------------------------------------------

}
#endif

void SMB_Write(void) {
	while (SMB_BUSY)
		; 				   // Wait for SMBus to be free.
	SMB_BUSY = 1;					   // Claim SMBus (set to busy)
	SMB_RW = 0;						   // Mark this transfer as a WRITE
	SMB0CN0_STA = 1; 				   // Start transfer
}

//-----------------------------------------------------------------------------
// SMB_Read
//-----------------------------------------------------------------------------
//
// Return Value : None
// Parameters   : None
//
// Reads a single byte from the slave with address specified by the <TARGET>
// variable.
// Calling sequence:
// 1) Write target slave address to the <TARGET> variable
// 2) Call SMB_Write()
// 3) Read input data from <SMB_DATA_IN> variable array
//
//-----------------------------------------------------------------------------
void SMB_Read(void) {
	while (SMB_BUSY)
		; 				   // Wait for bus to be free.
	SMB_BUSY = 1;					   // Claim SMBus (set to busy)
	SMB_RW = 1;						   // Mark this transfer as a READ

	SMB0CN0_STA = 1; 				   // Start transfer

	while (SMB_BUSY)
		; 				   // Wait for transfer to complete
}

//-----------------------------------------------------------------------------
// T0_Waitms
//-----------------------------------------------------------------------------
//
// Return Value : None
// Parameters   :
//   1) uint8_t ms - number of milliseconds to wait
//                        range is full range of character: 0 to 255
//
// Configure Timer0 to wait for <ms> milliseconds using SYSCLK as its time
// base.
//
//-----------------------------------------------------------------------------
void T0_Waitms(uint8_t ms) {
	TCON &= ~0x30;                      // Stop Timer0; Clear TCON_TF0
	TMOD &= ~0x0f;                      // 16-bit free run mode
	TMOD |= 0x01;

	CKCON0 |= 0x04;                     // Timer0 counts SYSCLKs

	while (ms) {
		TCON_TR0 = 0;                    // Stop Timer0
		TH0 = ((-SYSCLK / 1000) >> 8);     // Overflow in 1ms
		TL0 = ((-SYSCLK / 1000) & 0xFF);
		TCON_TF0 = 0;                    // Clear overflow indicator
		TCON_TR0 = 1;                    // Start Timer0
		while (!TCON_TF0)
			;               // Wait for overflow
		ms--;                            // Update ms counter
	}

	TCON_TR0 = 0;                       // Stop Timer0
}

