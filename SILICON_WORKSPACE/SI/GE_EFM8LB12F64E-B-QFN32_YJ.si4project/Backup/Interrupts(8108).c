//=========================================================
// src/Interrupts.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!!
//=========================================================

// USER INCLUDES
#include <SI_EFM8LB1_Register_Enums.h>
#include "EFM8LB1_I2C_Slave.h"

typedef enum {
	SLAVE_NORMAL_DATA, SLAVE_DATA_ADDRESS,
} SLAVE_WRITE_DATA_TYPE;

volatile uint8_t I2C1_slaveWriteData = 0x16;

#if 1
uint8_t EEPROM_Buffer[64] = { 0 };
#else
const uint8_t EEPROM_Buffer[] =
//uint8_t EEPROM_Buffer[] =
{
	17,		//B0
	5,
	6,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,

	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	56,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,//B127

	17,
	0,
	35,
	128,//136
	0,
	112,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	1,
	8,
	70,
	73,
	84,
	32,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	31,
	0,
	9,
	58,
	49,
	48,
	48,
	50,
	57,
	55,
	49,
	49,
	48,
	49,
	32,
	32,
	32,
	32,
	32,
	32,
	49,
	32,
	66,
	104,
	7,
	208,
	0,
	99,
	2,	//CR4=11 SR4=2 AOC=1»ò24
	0,
	0,
	0,
	53,
	50,
	56,
	54,
	50,
	48,
	55,
	53,
	48,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	49,
	53,
	49,
	48,
	49,
	51,
	32,
	32,
	0,
	0,
	0,
	41,

	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,

};
#endif

//-----------------------------------------------------------------------------
// I2C0_ISR
//-----------------------------------------------------------------------------
//
// I2C0 ISR Content goes here. Remember to clear flag bits:
// I2C0STAT::I2C0INT (I2C Interrupt)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (I2C0_ISR, I2C0_IRQn)
{
	static uint16_t eepromAddress = 0;  //for addressing larger than 256Byte
	static uint8_t slaveWriteType = SLAVE_NORMAL_DATA;
	static uint8_t WriteStat;

	switch (I2C0STAT & I2C_STATUS_VECTOR_MASK) {

		case I2C_ADDR_RD:
		I2C0STAT &= ~(I2C0STAT_START__BMASK | I2C0STAT_RD__BMASK);
		I2C0DOUT = EEPROM_Buffer[eepromAddress++];
		if(sizeof(EEPROM_Buffer) <= eepromAddress)
		{
			eepromAddress = 0;
		}
		break;

		case I2C_ADDR_WR:
		I2C0STAT &= ~(I2C0STAT_START__BMASK | I2C0STAT_WR__BMASK);
		slaveWriteType = SLAVE_DATA_ADDRESS;
		WriteStat = 1;
		break;

		case I2C_RD_DATA:
		if ((I2C0STAT & I2C0STAT_NACK__BMASK) == I2C0STAT_NACK__SET) {
			I2C0STAT &= ~I2C0STAT_NACK__BMASK;
		} else {
			I2C0DOUT = EEPROM_Buffer[eepromAddress++];
			if(sizeof(EEPROM_Buffer) <= eepromAddress)
			{
				eepromAddress = 0;
			}
		}
		I2C0STAT &= ~I2C0STAT_RD__BMASK;
		break;

		case I2C_WR_DATA:
		I2C0STAT &= ~I2C0STAT_WR__BMASK;

		break;

		case I2C_STOSTA:
		case I2C_STOSTARD:
		I2C0STAT &= ~I2C0STAT_STOP__BMASK;
		return;
		break;

		case I2C_STO:
		I2C0STAT &= ~I2C0STAT_STOP__BMASK;
		break;
		default:
		break;
	}

	while((I2C0FCN1 & I2C0FCN1_RXE__BMASK) == I2C0FCN1_RXE__NOT_EMPTY) {
		I2C1_slaveWriteData = I2C0DIN;
		if(1==WriteStat&&80!=I2C1_slaveWriteData)
		{
			switch(slaveWriteType)
			{
				case SLAVE_DATA_ADDRESS:
				if(I2C1_slaveWriteData>=128)
				{
					eepromAddress = I2C1_slaveWriteData+128*EEPROM_Buffer[127];
				}
				else
				{
					eepromAddress = I2C1_slaveWriteData;
				}
				break;

				case SLAVE_NORMAL_DATA:
				default:
				EEPROM_Buffer[eepromAddress++] = I2C1_slaveWriteData;

				if(sizeof(EEPROM_Buffer) <= eepromAddress)
				{
					eepromAddress = 0;
				}
				break;
			}

			slaveWriteType = SLAVE_NORMAL_DATA;
		}
	}

	I2C0STAT &= ~I2C0STAT_I2C0INT__BMASK;

}

//-----------------------------------------------------------------------------
// TIMER4_ISR
//-----------------------------------------------------------------------------
//
// TIMER4 ISR Content goes here. Remember to clear flag bits:
// TMR4CN0::TF4H (Timer # High Byte Overflow Flag)
// TMR4CN0::TF4L (Timer # Low Byte Overflow Flag)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (TIMER4_ISR, TIMER4_IRQn)
{
	SFRPAGE = PG3_PAGE;

	I2C0CN0 &= ~I2C0CN0_I2C0EN__BMASK;			// Disable I2C module
	I2C0CN0 |= I2C0CN0_I2C0EN__ENABLED;// Re-enable I2C module

	SFRPAGE = PG2_PAGE;
	TMR4CN0 &= ~TMR4CN0_TF4H__BMASK;// Clear Timer3 interrupt-pending flag
}

//-----------------------------------------------------------------------------
// UART0_ISR
//-----------------------------------------------------------------------------
//
// UART0 ISR Content goes here. Remember to clear flag bits:
// SCON0::RI (Receive Interrupt Flag)
// SCON0::TI (Transmit Interrupt Flag)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (UART0_ISR, UART0_IRQn)
{

}

//-----------------------------------------------------------------------------
// SMBUS0_ISR
//-----------------------------------------------------------------------------
//
// SMBUS0 ISR Content goes here. Remember to clear flag bits:
// SMB0CN0::SI (SMBus Interrupt Flag)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (SMBUS0_ISR, SMBUS0_IRQn)
{

}

//-----------------------------------------------------------------------------
// TIMER3_ISR
//-----------------------------------------------------------------------------
//
// TIMER3 ISR Content goes here. Remember to clear flag bits:
// TMR3CN0::TF3H (Timer # High Byte Overflow Flag)
// TMR3CN0::TF3L (Timer # Low Byte Overflow Flag)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (TIMER3_ISR, TIMER3_IRQn)
{

}

